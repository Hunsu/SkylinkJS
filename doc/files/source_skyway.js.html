<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/skyway.js - skywayjs</title>
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.svg" title="skywayjs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <span>
                API Docs for: <a href="http://temasys.github.io">0.5.2</a>
            </span>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Skyway.html">Skyway</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: source/skyway.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @class Skyway
 */
(function() {
  /**
   * Please check on the {{#crossLink &quot;Skyway/init:method&quot;}}init(){{/crossLink}}
   * function on how you can initialize Skyway. Note that:
   * - You will have to subscribe all Skyway events first before calling
   *   {{#crossLink &quot;Skyway/init:method&quot;}}init(){{/crossLink}}.
   * - If you need an api key, please [register an api key](http://
   *   developer.temasys.com.sg) at our developer console.
   * @class Skyway
   * @constructor
   * @example
   *   // Getting started on how to use Skyway
   *   var SkywayDemo = new Skyway();
   *   SkywayDemo.init(&#x27;apiKey&#x27;);
   *
   *   SkywayDemo.joinRoom(&#x27;my_room&#x27;, {
   *     userData: &#x27;My Username&#x27;,
   *     audio: true,
   *     video: true
   *   });
   *
   *   SkywayDemo.on(&#x27;incomingStream&#x27;, function (peerId, stream, isSelf) {
   *     if (isSelf) {
   *       attachMediaStream(document.getElementById(&#x27;selfVideo&#x27;), stream);
   *     } else {
   *       var peerVideo = document.createElement(&#x27;video&#x27;);
   *       peerVideo.id = peerId;
   *       peerVideo.autoplay = &#x27;autoplay&#x27;;
   *       document.getElementById(&#x27;peersVideo&#x27;).appendChild(peerVideo);
   *       attachMediaStream(peerVideo, stream);
   *     }
   *   });
   *
   *   SkywayDemo.on(&#x27;peerLeft&#x27;, function (peerId, peerInfo, isSelf) {
   *     if (isSelf) {
   *       document.getElementById(&#x27;selfVideo&#x27;).src = &#x27;&#x27;;
   *     } else {
   *       var peerVideo = document.getElementById(peerId);
   *       document.getElementById(&#x27;peersVideo&#x27;).removeChild(peerVideo);
   *     }
   *   });
   * @since 0.5.0
   */
  function Skyway() {
    if (!(this instanceof Skyway)) {
      return new Skyway();
    }

    /************************* Debugging Attributes ****************************/
    /**
     * Version of Skyway
     * @attribute VERSION
     * @type String
     * @readOnly
     * @since 0.1.0
     */
    this.VERSION = &#x27;@@version&#x27;;

    /**
     * The log levels.
     * - Logs are shown based on the level, if the level is highest, it shows logs
     *   which level are lower than theirs. If the level is lower, it shows only
     *   logs that are lower or are the same level, not the higher ones.
     * - Order from lowest to the highest is: error &gt; warn &gt; info &gt; log &gt; debug.
     * @attribute PEER_CONNECTION_STATE
     * @type JSON
     * @param {String} DEBUG Level 5. Shows debug logs.
     * @param {String} TRACE Level 4. Shows trace logs.
     * @param {String} INFO Level 3. Show informational logs related to user.
     * @param {String} WARN Level 2. Shows warnings.
     * @param {String} ERROR Level 1. Shows the errors that are thrown during
     *   execution.
     * @readOnly
     * @since 0.5.2
     */
    this.LOG_LEVEL = {
      DEBUG: &#x27;debug&#x27;,
      TRACE: &#x27;log&#x27;,
      INFO: &#x27;info&#x27;,
      WARN: &#x27;warn&#x27;,
      ERROR: &#x27;error&#x27;
    };

    /************************* Fixed Attributes ****************************/
    /**
     * The fixed size for each data chunk.
     * @attribute _CHUNK_FILE_SIZE
     * @type Integer
     * @readOnly
     * @private
     * @final
     * @required
     * @since 0.5.2
     */
    this._CHUNK_FILE_SIZE = 49152;

    /**
     * The fixed for each data chunk for firefox implementation.
     * - Firefox the sender chunks 49152 but receives as 16384.
     * @attribute _MOZ_CHUNK_FILE_SIZE
     * @type Integer
     * @readOnly
     * @private
     * @final
     * @required
     * @since 0.5.2
     */
    this._MOZ_CHUNK_FILE_SIZE = 16384;

    /**
     * The list of signaling message types.
     * - These are the list of available signaling message types expected to
     *   be received.
     * - These message types are fixed.
     * - The available message types are:
     * @attribute _SIG_MESSAGE_TYPE
     * @type JSON
     * @readOnly
     * @param {String} JOIN_ROOM
     * - Send: User request to join the room.
     * @param {String} IN_ROOM
     * - Received: Response from server that user has joined the room.
     * @param {String} ENTER
     * - Send: Broadcast message to inform other connected peers in the room
     *   that the user is the new peer joining the room.
     * - Received: A peer has just joined the room.
     *   To send a welcome message.
     * @param {String} WELCOME
     * - Send: Respond to user to request peer to create the offer.
     * - Received: Response from peer that peer acknowledges the user has
     *   joined the room. To send and create an offer message.
     * @param {String} OFFER
     * - Send: Respond to peer&#x27;s request to create an offer.
     * - Received: Response from peer&#x27;s offer message. User to create and
     *   send an answer message.
     * @param {String} ANSWER
     * - Send: Response to peer&#x27;s offer message.
     * - Received: Response from peer&#x27;s answer message.
     *   Connection is established.
     * @param {String} CANDIDATE
     * - Send: User to send the ICE candidate after onicecandidate is called.
     * - Received: User to add peer&#x27;s ice candidate in addIceCandidate.
     * @param {String} BYE
     * - Received: Peer has left the room.
     * @param {String} REDIRECT
     * - Received: Server warning to user.
     * @param {String} ERROR
     * - Received: Deprecated. Server error occurred.
     * @param {String} UPDATE_USER
     * - Send: User&#x27;s custom data is updated and to inform other peers
     *   of updated custom data.
     * - Received: Peer&#x27;s user custom data has changed.
     * @param {String} ROOM_LOCK
     * - Send: Room lock action has changed and to inform other peers
     *   of updated room lock status.
     * - Received: Room lock status has changed.
     * @param {String} MUTE_VIDEO
     * - Send: User has muted video and to inform other peers
     *   of updated muted video stream status.
     * - Received: Peer muted video status has changed.
     * @param {String} MUTE_AUDIO
     * - Send: User has muted audio and to inform other peers
     *   of updated muted audio stream status.
     * - Received: Peer muted audio status has changed.
     * @param {String} PUBLIC_MESSAGE
     * - Send: User sends a broadcast message to all peers.
     * - Received: User receives a peer&#x27;s broadcast message.
     * @param {String} PRIVATE_MESSAGE
     * - Send: User sends a private message to a peer.
     * - Received: User receives a private message from a peer.
     * @readOnly
     * @private
     * @since 0.5.2
     */
    this._SIG_MESSAGE_TYPE = {
      JOIN_ROOM: &#x27;joinRoom&#x27;,
      IN_ROOM: &#x27;inRoom&#x27;,
      ENTER: &#x27;enter&#x27;,
      WELCOME: &#x27;welcome&#x27;,
      OFFER: &#x27;offer&#x27;,
      ANSWER: &#x27;answer&#x27;,
      CANDIDATE: &#x27;candidate&#x27;,
      BYE: &#x27;bye&#x27;,
      REDIRECT: &#x27;redirect&#x27;,
      UPDATE_USER: &#x27;updateUserEvent&#x27;,
      ROOM_LOCK: &#x27;roomLockEvent&#x27;,
      MUTE_VIDEO: &#x27;muteVideoEvent&#x27;,
      MUTE_AUDIO: &#x27;muteAudioEvent&#x27;,
      PUBLIC_MESSAGE: &#x27;public&#x27;,
      PRIVATE_MESSAGE: &#x27;private&#x27;,
      GROUP: &#x27;group&#x27;
    };

    /**
     * The list of datachannel message types.
     * - These are the list of available datachannel message types expected to
     *   be received.
     * - These message types are fixed.
     * - The available message types are:
     * @attribute _DC_PROTOCOL_TYPE
     * @type JSON
     * @readOnly
     * @param {String} WRQ
     * - Send: User request to transfer a data.
     * - Received: A peer has requested to transfer a data.
     * @param {String} ACK
     * - Send: User response to data transfer request.
     * - Received: Response from peer towards data transfer.
     *   - -1: Peer has rejected data transfer request.
     *   - 0: Peer has accepted data transfer request.
     *   - &gt;0: Data transfer is going on.
     * @param {String} CANCEL
     * - Send: User canceled data transfer.
     * - Received: A peer has canceled data transfer.
     * @param {String} ERROR
     * - Send: Timeout waiting for peer response has exceeded limit.
     * - Received: Response from peer that timeout has reached its limit.
     *   Data transfer has failed.
     * @param {String} MESSAGE
     * - Send: User sends a P2P message.
     * - Received: A peer has sent a P2P message.
     * @readOnly
     * @private
     * @since 0.5.2
     */
    this._DC_PROTOCOL_TYPE = {
      WRQ: &#x27;WRQ&#x27;,
      ACK: &#x27;ACK&#x27;,
      ERROR: &#x27;ERROR&#x27;,
      CANCEL: &#x27;CANCEL&#x27;,
      MESSAGE: &#x27;MESSAGE&#x27;
    };

    /************************* Developer Fixed Attributes ****************************/
    /**
     * The list of available regional servers.
     * - This is for developers to set the nearest region server
     *   for Skyway to connect to for faster connectivity.
     * - The available regional servers are:
     * @attribute REGIONAL_SERVER
     * @type JSON
     * @param {String} APAC1 Asia pacific server 1.
     * @param {String} US1 server 1.
     * @readOnly
     * @since 0.5.0
     */
    this.REGIONAL_SERVER = {
      APAC1: &#x27;sg&#x27;,
      US1: &#x27;us2&#x27;
    };

    /**
     * The list of ICE connection states.
     * - Check out the [w3 specification documentation](http://dev.w3.org/2011/
     *   webrtc/editor/webrtc.html#rtciceconnectionstate-enum).
     * - This is the RTCIceConnection state of the peer.
     * - The states that would occur are:
     * @attribute ICE_CONNECTION_STATE
     * @type JSON
     * @param {String} STARTING The ICE agent is gathering addresses
     *   and/or waiting for remote candidates to be supplied.
     * @param {String} CHECKING The ICE agent has received remote candidates
     *   on at least one component, and is checking candidate pairs but has
     *   not yet found a connection. In addition to checking, it may also
     *   still be gathering.
     * @param {String} CONNECTED The ICE agent has found a usable connection
     *   for all components but is still checking other candidate pairs to see
     *   if there is a better connection. It may also still be gathering.
     * @param {String} COMPLETED The ICE agent has finished gathering and
     *   checking and found a connection for all components.
     * @param {String} FAILED The ICE agent is finished checking all
     *   candidate pairs and failed to find a connection for at least one
     *   component.
     * @param {String} DISCONNECTED Liveness checks have failed for one or
     *   more components. This is more aggressive than &quot;failed&quot;, and may
     *   trigger intermittently (and resolve itself without action) on
     *   a flaky network.
     * @param {String} CLOSED The ICE agent has shut down and is no
     *   longer responding to STUN requests.
     * @readOnly
     * @since 0.1.0
     */
    this.ICE_CONNECTION_STATE = {
      STARTING: &#x27;starting&#x27;,
      CHECKING: &#x27;checking&#x27;,
      CONNECTED: &#x27;connected&#x27;,
      COMPLETED: &#x27;completed&#x27;,
      CLOSED: &#x27;closed&#x27;,
      FAILED: &#x27;failed&#x27;,
      DISCONNECTED: &#x27;disconnected&#x27;
    };

    /**
     * The list of peer connection states.
     * - Check out the [w3 specification documentation](http://dev.w3.org/2011/
     *   webrtc/editor/webrtc.html#rtcpeerstate-enum).
     * - This is the RTCSignalingState of the peer.
     * - The states that would occur are:
     * @attribute PEER_CONNECTION_STATE
     * @type JSON
     * @param {String} STABLE There is no offer/answer exchange in progress.
     *   This is also the initial state in which case the local and remote
     *   descriptions are empty.
     * @param {String} HAVE_LOCAL_OFFER A local description, of type &quot;offer&quot;,
     *   has been successfully applied.
     * @param {String} HAVE_REMOTE_OFFER A remote description, of type &quot;offer&quot;,
     *   has been successfully applied.
     * @param {String} HAVE_LOCAL_PRANSWER A remote description of type &quot;offer&quot;
     *   has been successfully applied and a local description of type &quot;pranswer&quot;
     *   has been successfully applied.
     * @param {String} HAVE_REMOTE_PRANSWER A local description of type &quot;offer&quot;
     *   has been successfully applied and a remote description of type
     *   &quot;pranswer&quot; has been successfully applied.
     * @param {String} CLOSED The connection is closed.
     * @readOnly
     * @since 0.5.0
     */
    this.PEER_CONNECTION_STATE = {
      STABLE: &#x27;stable&#x27;,
      HAVE_LOCAL_OFFER: &#x27;have-local-offer&#x27;,
      HAVE_REMOTE_OFFER: &#x27;have-remote-offer&#x27;,
      HAVE_LOCAL_PRANSWER: &#x27;have-local-pranswer&#x27;,
      HAVE_REMOTE_PRANSWER: &#x27;have-remote-pranswer&#x27;,
      CLOSED: &#x27;closed&#x27;
    };

    /**
     * The list of ICE candidate generation states.
     * - Check out the [w3 specification documentation](http://dev.w3.org/2011/
     *   webrtc/editor/webrtc.html#rtcicegatheringstate-enum).
     * - This is RTCIceGatheringState of the peer.
     * - The states that would occur are:
     * @attribute CANDIDATE_GENERATION_STATE
     * @type JSON
     * @param {String} NEW The object was just created, and no networking
     *   has occurred yet.
     * @param {String} GATHERING The ICE engine is in the process of gathering
     *   candidates for this RTCPeerConnection.
     * @param {String} COMPLETED The ICE engine has completed gathering. Events
     *   such as adding a new interface or a new TURN server will cause the
     *   state to go back to gathering.
     * @readOnly
     * @since 0.4.1
     */
    this.CANDIDATE_GENERATION_STATE = {
      NEW: &#x27;new&#x27;,
      GATHERING: &#x27;gathering&#x27;,
      COMPLETED: &#x27;completed&#x27;
    };

    /**
     * The list of handshake progress steps.
     * - This are the list of steps for the Skyway peer connection.
     * - The steps that would occur are:
     * @type JSON
     * @attribute HANDSHAKE_PROGRESS
     * @param {String} ENTER Step 1. Received &quot;enter&quot; from peer.
     * @param {String} WELCOME Step 2. Received &quot;welcome&quot; from peer.
     * @param {String} OFFER Step 3. Received &quot;offer&quot; from peer.
     * @param {String} ANSWER Step 4. Received &quot;answer&quot; from peer.
     * @param {String} ERROR Error state.
     * @readOnly
     * @since 0.1.0
     */
    this.HANDSHAKE_PROGRESS = {
      ENTER: &#x27;enter&#x27;,
      WELCOME: &#x27;welcome&#x27;,
      OFFER: &#x27;offer&#x27;,
      ANSWER: &#x27;answer&#x27;,
      ERROR: &#x27;error&#x27;
    };

    /**
     * The list of datachannel states.
     * - Check out the [w3 specification documentation](http://dev.w3.org/2011/
     *   webrtc/editor/webrtc.html#idl-def-RTCDataChannelState).
     * - This is the RTCDataChannelState of the peer.
     * - &lt;u&gt;ERROR&lt;/u&gt; is an additional implemented state by Skyway
     *   for further error tracking.
     * - The states that would occur are:
     * @attribute DATA_CHANNEL_STATE
     * @type JSON
     * @param {String} CONNECTING The user agent is attempting to establish
     *   the underlying data transport. This is the initial state of a
     *   RTCDataChannel object created with createDataChannel().
     * @param {String} OPEN The underlying data transport is established
     *   and communication is possible. This is the initial state of a
     *   RTCDataChannel object dispatched as a part of a RTCDataChannelEvent.
     * @param {String} CLOSING The procedure to close down the underlying
     *   data transport has started.
     * @param {String} CLOSED The underlying data transport has been closed
     *   or could not be established.
     * @param {String} ERROR Datachannel has occurred an error.
     * @readOnly
     * @since 0.1.0
     */
    this.DATA_CHANNEL_STATE = {
      CONNECTING: &#x27;connecting&#x27;,
      OPEN: &#x27;open&#x27;,
      CLOSING: &#x27;closing&#x27;,
      CLOSED: &#x27;closed&#x27;,
      ERROR: &#x27;error&#x27;
    };

    /**
     * The list of api server data retrieval state.
     * - These are the states to inform the state of retrieving the
     *   information from the api server required to start the peer
     *   connection or if the browser is eligible to start the peer connection.
     * - This is the first event that would fired, because Skyway would retrieve
     *   information from the api server that is required to start the connection.
     * - Once the state is &lt;u&gt;COMPLETED&lt;/u&gt;, Skyway is ready to start the call.
     * - The states that would occur are:
     * @attribute READY_STATE_CHANGE
     * @type JSON
     * @param {Integer} INIT Skyway has just started. No information are
     *   retrieved yet.
     * @param {Integer} LOADING Skyway is starting the retrieval of the
     *   connection information.
     * @param {Integer} COMPLETED Skyway has completed retrieving the
     *   connection.
     * @param {Integer} ERROR Skyway has occurred an error when
     *   retrieving the connection information.
     * @readOnly
     * @since 0.1.0
     */
    this.READY_STATE_CHANGE = {
      INIT: 0,
      LOADING: 1,
      COMPLETED: 2,
      ERROR: -1
    };

    /**
     * The list of ready state change errors.
     * - These are the error states from the error object error code.
     * - &lt;b&gt;ROOM_LOCKED&lt;/b&gt; is deprecated in 0.5.2. Please use
     *   {{#crossLink &quot;Skyway/:attr&quot;}}leaveRoom(){{/crossLink}}
     * - The states that would occur are:
     * @attribute READY_STATE_CHANGE_ERROR
     * @type JSON
     * @param {Integer} API_INVALID  Api Key provided does not exist.
     * @param {Integer} API_DOMAIN_NOT_MATCH Api Key used in domain does
     *   not match.
     * @param {Integer} API_CORS_DOMAIN_NOT_MATCH Api Key used in CORS
     *   domain does not match.
     * @param {Integer} API_CREDENTIALS_INVALID Api Key credentials does
     *   not exist.
     * @param {Integer} API_CREDENTIALS_NOT_MATCH Api Key credentials does not
     *   match what is expected.
     * @param {Integer} API_INVALID_PARENT_KEY Api Key does not have a parent
     *   key nor is a root key.
     * @param {Integer} API_NOT_ENOUGH_CREDIT Api Key does not have enough
     *   credits to use.
     * @param {Integer} API_NOT_ENOUGH_PREPAID_CREDIT Api Key does not have
     *   enough prepaid credits to use.
     * @param {Integer} API_FAILED_FINDING_PREPAID_CREDIT Api Key preapid
     *   payments does not exist.
     * @param {Integer} API_NO_MEETING_RECORD_FOUND Api Key does not have a
     *   meeting record at this timing. This occurs when Api Key is a
     *   static one.
     * @param {Integer} ROOM_LOCKED Room is locked.
     * @param {Integer} NO_SOCKET_IO No socket.io dependency is loaded to use.
     * @param {Integer} NO_XMLHTTPREQUEST_SUPPORT Browser does not support
     *   XMLHttpRequest to use.
     * @param {Integer} NO_WEBRTC_SUPPORT Browser does not have WebRTC support.
     * @param {Integer} NO_PATH No path is loaded yet.
     * @param {Integer} INVALID_XMLHTTPREQUEST_STATUS Invalid XMLHttpRequest
     *   when retrieving information.
     * @readOnly
     * @since 0.4.0
     */
    this.READY_STATE_CHANGE_ERROR = {
      API_INVALID: 4001,
      API_DOMAIN_NOT_MATCH: 4002,
      API_CORS_DOMAIN_NOT_MATCH: 4003,
      API_CREDENTIALS_INVALID: 4004,
      API_CREDENTIALS_NOT_MATCH: 4005,
      API_INVALID_PARENT_KEY: 4006,
      API_NOT_ENOUGH_CREDIT: 4007,
      API_NOT_ENOUGH_PREPAID_CREDIT: 4008,
      API_FAILED_FINDING_PREPAID_CREDIT: 4009,
      API_NO_MEETING_RECORD_FOUND: 4010,
      ROOM_LOCKED: 5001,
      NO_SOCKET_IO: 1,
      NO_XMLHTTPREQUEST_SUPPORT: 2,
      NO_WEBRTC_SUPPORT: 3,
      NO_PATH: 4,
      INVALID_XMLHTTPREQUEST_STATUS: 5,
      SCRIPT_ERROR: 6
    };

    /**
     * The list of recommended video resolutions.
     * - Note that the higher the resolution, the connectivity speed might
     *   be affected.
     * - The available video resolutions type are:
     * @param {JSON} QVGA QVGA video resolution.
     * @param {Integer} QVGA.width 320
     * @param {Integer} QVGA.height 180
     * @param {JSON} VGA VGA video resolution.
     * @param {Integer} VGA.width 640
     * @param {Integer} VGA.height 360
     * @param {JSON} HD HD video quality
     * @param {Integer} HD.width 1280
     * @param {Integer} HD.height 720
     * @param {JSON} FHD Might not be supported. Full HD video resolution.
     * @param {Integer} FHD.width 1920
     * @param {Integer} FHD.height 1080
     * @attribute VIDEO_RESOLUTION
     * @type JSON
     * @readOnly
     * @since 0.2.0
     */
    this.VIDEO_RESOLUTION = {
      QVGA: {
        width: 320,
        height: 180
      },
      VGA: {
        width: 640,
        height: 360
      },
      HD: {
        width: 1280,
        height: 720
      },
      FHD: {
        width: 1920,
        height: 1080
      } // Please check support
    };

    /**
     * The list of datachannel transfer types.
     * - This is used to identify if the stream is an upload stream or
     *   a download stream.
     * - The available types are:
     * @attribute DATA_TRANSFER_TYPE
     * @type JSON
     * @param {String} UPLOAD The datachannel transfer is an upload stream.
     * @param {String} DOWNLOAD The datachannel transfer is a download stream.
     * @readOnly
     * @since 0.1.0
     */
    this.DATA_TRANSFER_TYPE = {
      UPLOAD: &#x27;upload&#x27;,
      DOWNLOAD: &#x27;download&#x27;
    };
    /**
     * The list of datachannel transfer state.
     * - These are the states to inform the state of the data transfer.
     * - The list of states would occur are:
     * @attribute DATA_TRANSFER_STATE
     * @type JSON
     * @param {String} UPLOAD_REQUEST Peer has a data transfer request.
     * @param {String} UPLOAD_STARTED Data transfer of upload has just started.
     * @param {String} DOWNLOAD_STARTED Data transfer of download has
     *   just started.
     * @param {String} UPLOADING Data upload transfer is occurring.
     * @param {String} DOWNLOADING Data download transfer is occurring.
     * @param {String} UPLOAD_COMPLETED Data upload transfer has been completed.
     * @param {String} DOWNLOAD_COMPLETED Data download transfer has been
     *   completed.
     * @param {String} REJECTED Peer rejected user&#x27;s data transfer request.
     * @param {String} ERROR Data transfer had an error occurred
     *   when uploading or downloading file.
     * @readOnly
     * @since 0.4.0
     */
    this.DATA_TRANSFER_STATE = {
      UPLOAD_REQUEST: &#x27;request&#x27;,
      UPLOAD_STARTED: &#x27;uploadStarted&#x27;,
      DOWNLOAD_STARTED: &#x27;downloadStarted&#x27;,
      REJECTED: &#x27;rejected&#x27;,
      CANCEL: &#x27;cancel&#x27;,
      ERROR: &#x27;error&#x27;,
      UPLOADING: &#x27;uploading&#x27;,
      DOWNLOADING: &#x27;downloading&#x27;,
      UPLOAD_COMPLETED: &#x27;uploadCompleted&#x27;,
      DOWNLOAD_COMPLETED: &#x27;downloadCompleted&#x27;
    };

    /**
     * The list of data transfer data types.
     * - &lt;b&gt;&lt;i&gt;TODO&lt;/i&gt;&lt;/b&gt;: ArrayBuffer and Blob data transfer in
     *   datachannel.
     * - The available data transfer data types are:
     * @attribute DATA_TRANSFER_DATA_TYPE
     * @type JSON
     * @param {String} BINARY_STRING BinaryString data type.
     * @param {String} ARRAY_BUFFER Still-implementing. ArrayBuffer data type.
     * @param {String} BLOB Still-implementing. Blob data type.
     * @readOnly
     * @since 0.1.0
     */
    this.DATA_TRANSFER_DATA_TYPE = {
      BINARY_STRING: &#x27;binaryString&#x27;,
      ARRAY_BUFFER: &#x27;arrayBuffer&#x27;,
      BLOB: &#x27;blob&#x27;
    };

    /**
     * The list of signaling actions received.
     * - These are usually received from the signaling server to warn the user.
     * - The system action outcomes are:
     * @attribute SYSTEM_ACTION
     * @type JSON
     * @param {String} WARNING Server is warning user to take actions.
     * @param {String} REJECT Server has rejected user from room.
     * @readOnly
     * @since 0.5.1
     */
    this.SYSTEM_ACTION = {
      WARNING: &#x27;warning&#x27;,
      REJECT: &#x27;reject&#x27;
    };

    /**
     * The list of signaling actions received.
     * - These are usually received from the signaling server to warn the user.
     * - The system action outcomes are:
     * @attribute SYSTEM_ACTION_REASON
     * @type JSON
     * @param {String} FAST_MESSAGE User sends quick messages
     *   less than a second resulting in a warning. Continuous
     *   quick messages results in user being kicked out of the room.
     * @param {String} ROOM_LOCKED Room is locked and user is locked
     *   from joining the room.
     * @param {String} ROOM_FULL Persistent meeting. Room is full.
     * @param {String} DUPLICATED_LOGIN User has same id
     * @param {String} SERVER_ERROR Server has an error
     * @param {String} VERIFICATION Verification for roomID
     * @param {String} EXPIRED Persistent meeting. Room has
     *   expired and user is unable to join the room.
     * @param {String} ROOM_CLOSED Persistent meeting. Room
     *   has expired and is closed, user to leave the room.
     * @param {String} ROOM_CLOSING Persistent meeting.
     *   Room is closing soon.
     * @param {String} OVER_SEAT_LIMIT Seat limit is hit. API Key
     *   do not have sufficient seats to continue.
     * @readOnly
     * @since 0.5.2
     */
    this.SYSTEM_ACTION_REASON = {
      FAST_MESSAGE: &#x27;fastmsg&#x27;,
      ROOM_LOCKED: &#x27;locked&#x27;,
      ROOM_FULL: &#x27;roomfull&#x27;,
      DUPLICATED_LOGIN: &#x27;duplicatedLogin&#x27;,
      SERVER_ERROR: &#x27;serverError&#x27;,
      VERIFICATION: &#x27;verification&#x27;,
      EXPIRED: &#x27;expired&#x27;,
      ROOM_CLOSED: &#x27;roomclose&#x27;,
      ROOM_CLOSING: &#x27;toclose&#x27;,
      OVER_SEAT_LIMIT: &#x27;seatquota&#x27;
    };

    /************************* Stored Preferences Attributes ****************************/
    /**
     * The log level of Skyway
     * @attribute _logLevel
     * @type String
     * @default &#x27;warn&#x27;
     * @required
     * @private
     * @since 0.5.2
     */
    this._logLevel = &#x27;warn&#x27;;

    /**
     * The path that user is currently connect to.
     * - NOTE ALEX: check if last char is &#x27;/&#x27;
     * @attribute _path
     * @type String
     * @default _serverPath
     * @final
     * @required
     * @private
     * @since 0.1.0
     */
    this._path = null;

    /**
     * The regional server that Skyway connects to.
     * @attribute _serverRegion
     * @type String
     * @private
     * @since 0.5.0
     */
    this._serverRegion = null;

    /**
     * The server that user connects to to make
     * api calls to.
     * - The reason why users can input this value is to give
     *   users the chance to connect to any of our beta servers
     *   if available instead of the stable version.
     * @attribute _roomServer
     * @type String
     * @default &#x27;//api.temasys.com.sg&#x27;
     * @private
     * @since 0.5.2
     */
    this._roomServer = &#x27;//api.temasys.com.sg&#x27;;

    /**
     * The API Key ID.
     * @attribute _apiKey
     * @type String
     * @private
     * @since 0.3.0
     */
    this._apiKey = null;

    /**
     * The default room that the user connects to if no room is provided in
     * {{#crossLink &quot;Skyway/joinRoom:method&quot;}}joinRoom(){{/crossLink}}.
     * @attribute _defaultRoom
     * @type String
     * @private
     * @since 0.3.0
     */
    this._defaultRoom = null;

    /**
     * The room that the user is currently connected to.
     * @attribute _selectedRoom
     * @type String
     * @default _defaultRoom
     * @private
     * @since 0.3.0
     */
    this._selectedRoom = null;

    /**
     * The static room&#x27;s meeting starting date and time.
     * - The value is in ISO formatted string.
     * @attribute _roomStart
     * @type String
     * @private
     * @optional
     * @since 0.3.0
     */
    this._roomStart = null;

    /**
     * The static room&#x27;s meeting duration.
     * @attribute _roomDuration
     * @type Integer
     * @private
     * @optional
     * @since 0.3.0
     */
    this._roomDuration = null;

    /**
     * The credentials required to set the start date and time
     * and the duration.
     * @attribute _roomCredentials
     * @type String
     * @private
     * @optional
     * @since 0.3.0
     */
    this._roomCredentials = null;

    /**
     * The current state if ICE trickle is enabled.
     * @attribute _enableIceTrickle
     * @type Boolean
     * @default true
     * @private
     * @required
     * @since 0.3.0
     */
    this._enableIceTrickle = true;

    /**
     * The current state if datachannel is enabled.
     * @attribute _enableDataChannel
     * @type Boolean
     * @default true
     * @private
     * @required
     * @since 0.3.0
     */
    this._enableDataChannel = true;

    /**
     * The current state if debugging mode is enabled.
     * @attribute _enableDebugMode
     * @type Boolean
     * @default false
     * @private
     * @required
     * @since 0.5.2
     */
    this._enableDebugMode = false;

    /**
     * The user stream settings.
     * - By default, all is false.
     * @attribute _streamSettings
     * @type JSON
     * @default {
     *   &#x27;audio&#x27; : false,
     *   &#x27;video&#x27; : false
     * }
     * @private
     * @since 0.2.0
     */
    this._streamSettings = {
      audio: false,
      video: false
    };

    /************************* Current State Attributes ****************************/

    /**
     * The current Skyway ready state change.
     * [Rel: Skyway.READY_STATE_CHANGE]
     * @attribute _readyState
     * @type Integer
     * @private
     * @required
     * @since 0.1.0
     */
    this._readyState = 0;

    /**
     * The current socket opened state.
     * @attribute _channelOpen
     * @type Boolean
     * @private
     * @required
     * @since 0.5.2
     */
    this._channelOpen = false;

    /**
     * The current state if room is locked.
     * @attribute _roomLocked
     * @type Boolean
     * @private
     * @required
     * @since 0.5.2
     */
    this._roomLocked = false;

    /************************* Connection Information Attributes ****************************/
    /**
     * The received server key.
     * @attribute _key
     * @type String
     * @private
     * @since 0.1.0
     */
    this._key = null;

    /**
     * The owner&#x27;s username of the apiKey.
     * @attribute _apiKeyOwner
     * @type String
     * @private
     * @since 0.5.2
     */
    this._apiKeyOwner = null;

    /**
     * The signaling server to connect to.
     * @attribute _signalingServer
     * @type String
     * @private
     * @since 0.5.2
     */
    this._signalingServer = null;

    /**
     * The signaling server port to connect to.
     * @attribute _signalingServerPort
     * @type String
     * @private
     * @since 0.5.2
     */
    this._signalingServerPort = null;

    /**
     * The actual socket object that handles the connection.
     * @attribute _socket
     * @type Object
     * @required
     * @private
     * @since 0.1.0
     */
    this._socket = null;

    /**
     * User information, credential and the local stream(s).
     * @attribute _user
     * @type JSON
     * @param {String} uid The user&#x27;s session id.
     * @param {String} sid The user&#x27;s secret id. This is the id used as the peerId.
     * @param {String} timestamp The user&#x27;s timestamp.
     * @param {String} token The user&#x27;s access token.
     * @param {Array} streams The array of user&#x27;s MediaStream(s).
     * @param {JSON} info The user&#x27;s peer information object.
     * @param {JSON} info.settings User stream settings.
     * @param {Boolean|JSON} info.settings.audio User audio settings.
     * @param {Boolean} info.settings.audio.stereo User has enabled stereo or not.
     * @param {Boolean|JSON} info.settings.video User video settings.
     * @param {Bolean|JSON} info.settings.video.resolution User video
     *   resolution set. [Rel: Skyway.VIDEO_RESOLUTION]
     * @param {Integer} info.settings.video.resolution.width User video
     *   resolution width.
     * @param {Integer} info.settings.video.resolution.height User video
     *   resolution height.
     * @param {Integer} info.settings.video.frameRate User video minimum
     *   frame rate.
     * @param {JSON} info.mediaStatus User MediaStream(s) status.
     * @param {Boolean} info.mediaStatus.audioMuted Is user&#x27;s audio muted.
     * @param {Boolean} info.mediaStatus.videoMuted Is user&#x27;s vide muted.
     * @param {String|JSON} info.userData User&#x27;s custom data set.
     * @required
     * @private
     * @since 0.5.2
     */
    this._user = null;

    /**
     * The room connection information.
     * @attribute _room
     * @type JSON
     * @param {String} id The roomId of the room user is connected to.
     * @param {String} token The token of the room user is connected to.
     * @param {String} startDateTime The startDateTime in ISO string format of the room.
     * @param {String} duration The duration of the room.
     * @param {JSON} connection Connection constraints and configuration.
     * @param {JSON} connection.peerConstraints The peerconnection constraints.
     * @param {JSON} connection.peerConfig The peerconnection configuration.
     * @param {JSON} connection.offerConstraints The offer constraints.
     * @param {JSON} connection.sdpConstraints The sdp constraints.
     * @required
     * @private
     * @since 0.5.2
     */
    this._room = null;

    /************************* Internal Session Array Attributes ****************************/
    /**
     * Internal array of peer connections.
     * @attribute _peerConnections
     * @type Object
     * @required
     * @private
     * @since 0.1.0
     */
    this._peerConnections = [];

    /**
     * Internal array of peer informations.
     * @attribute _peerInformations
     * @type Object
     * @private
     * @required
     * @since 0.3.0
     */
    this._peerInformations = [];

    /**
     * Internal array of peer ice candidates queue.
     * @attribute _peerCandidatesQueue
     * @type Object
     * @private
     * @required
     * @since 0.5.1
     */
    this._peerCandidatesQueue = [];

    /**
     * Internal array of peer handshake messaging priorities.
     * @attribute _peerHSPriorities
     * @type Object
     * @private
     * @required
     * @since 0.5.0
     */
    this._peerHSPriorities = [];

    /**
     * Internal array of datachannels.
     * @attribute _dataChannels
     * @type Object
     * @private
     * @required
     * @since 0.2.0
     */
    this._dataChannels = [];

    /**
     * Internal array of data upload transfers.
     * @attribute _uploadDataTransfers
     * @type Array
     * @private
     * @required
     * @since 0.4.1
     */
    this._uploadDataTransfers = [];

    /**
     * Internal array of data upload sessions.
     * @attribute _uploadDataSessions
     * @type Array
     * @private
     * @required
     * @since 0.4.1
     */
    this._uploadDataSessions = [];

    /**
     * Internal array of data download transfers.
     * @attribute _downloadDataTransfers
     * @type Array
     * @private
     * @required
     * @since 0.4.1
     */
    this._downloadDataTransfers = [];

    /**
     * Internal array of data download sessions.
     * @attribute _downloadDataSessions
     * @type Array
     * @private
     * @required
     * @since 0.4.1
     */
    this._downloadDataSessions = [];

    /**
     * Internal array of data transfers timeout.
     * @attribute _dataTransfersTimeout
     * @type Array
     * @private
     * @required
     * @since 0.4.1
     */
    this._dataTransfersTimeout = [];

    /************************* Event Attributes ****************************/
    /**
     * Syntactically private variables and utility functions.
     * @attribute _EVENTS
     * @type JSON
     * @private
     * @final
     * @required
     * @since 0.5.2
     */
    this._EVENTS = {
      /**
       * Event fired when the socket connection to the signaling
       * server is open.
       * @event channelOpen
       * @since 0.1.0
       */
      channelOpen: [],

      /**
       * Event fired when the socket connection to the signaling
       * server has closed.
       * @event channelClose
       * @since 0.1.0
       */
      channelClose: [],

      /**
       * Event fired when the socket connection received a message
       * from the signaling server.
       * @event channelMessage
       * @param {JSON} message
       * @since 0.1.0
       */
      channelMessage: [],

      /**
       * Event fired when the socket connection has occurred an error.
       * @event channelError
       * @param {Object|String} error Error message or object thrown.
       * @since 0.1.0
       */
      channelError: [],

      /**
       * Event fired whether the room is ready for use.
       * @event readyStateChange
       * @param {String} readyState [Rel: Skyway.READY_STATE_CHANGE]
       * @param {JSON} error Error object thrown.
       * @param {Integer} error.status Http status when retrieving information.
       *   May be empty for other errors.
       * @param {String} error.content Error message.
       * @param {Integer} error.errorCode Error code.
       *   [Rel: Skyway.READY_STATE_CHANGE_ERROR]
       * @since 0.4.0
       */
      readyStateChange: [],

      /**
       * Event fired when a peer&#x27;s handshake progress has changed.
       * @event handshakeProgress
       * @param {String} step The handshake progress step.
       *   [Rel: Skyway.HANDSHAKE_PROGRESS]
       * @param {String} peerId PeerId of the peer&#x27;s handshake progress.
       * @param {Object|String} error Error message or object thrown.
       * @since 0.3.0
       */
      handshakeProgress: [],

      /**
       * Event fired when an ICE gathering state has changed.
       * @event candidateGenerationState
       * @param {String} state The ice candidate generation state.
       *   [Rel: Skyway.CANDIDATE_GENERATION_STATE]
       * @param {String} peerId PeerId of the peer that had an ice candidate
       *    generation state change.
       * @since 0.1.0
       */
      candidateGenerationState: [],

      /**
       * Event fired when a peer Connection state has changed.
       * @event peerConnectionState
       * @param {String} state The peer connection state.
       *   [Rel: Skyway.PEER_CONNECTION_STATE]
       * @param {String} peerId PeerId of the peer that had a peer connection state
       *    change.
       * @since 0.1.0
       */
      peerConnectionState: [],

      /**
       * Event fired when an ICE connection state has changed.
       * @iceConnectionState
       * @param {String} state The ice connection state.
       *   [Rel: Skyway.ICE_CONNECTION_STATE]
       * @param {String} peerId PeerId of the peer that had an ice connection state change.
       * @since 0.1.0
       */
      iceConnectionState: [],

      /**
       * Event fired when webcam or microphone media access fails.
       * @event mediaAccessError
       * @param {Object|String} error Error object thrown.
       * @since 0.1.0
       */
      mediaAccessError: [],

      /**
       * Event fired when webcam or microphone media acces passes.
       * @event mediaAccessSuccess
       * @param {Object} stream MediaStream object.
       * @since 0.1.0
       */
      mediaAccessSuccess: [],

      /**
       * Event fired when a peer joins the room.
       * @event peerJoined
       * @param {String} peerId PeerId of the peer that joined the room.
       * @param {JSON} peerInfo Peer&#x27;s information.
       * @param {JSON} peerInfo.settings Peer&#x27;s stream settings.
       * @param {Boolean|JSON} peerInfo.settings.audio Peer&#x27;s audio stream
       *   settings.
       * @param {Boolean} peerInfo.settings.audio.stereo If peer has stereo
       *   enabled or not.
       * @param {Boolean|JSON} peerInfo.settings.video Peer&#x27;s video stream
       *   settings.
       * @param {JSON} peerInfo.settings.video.resolution
       *   Peer&#x27;s video stream resolution [Rel: Skyway.VIDEO_RESOLUTION]
       * @param {Integer} peerInfo.settings.video.resolution.width
       *   Peer&#x27;s video stream resolution width.
       * @param {Integer} peerInfo.settings.video.resolution.height
       *   Peer&#x27;s video stream resolution height.
       * @param {Integer} peerInfo.settings.video.frameRate
       *   Peer&#x27;s video stream resolution minimum frame rate.
       * @param {JSON} peerInfo.mediaStatus Peer stream status.
       * @param {Boolean} peerInfo.mediaStatus.audioMuted If peer&#x27;s audio
       *   stream is muted.
       * @param {Boolean} peerInfo.mediaStatus.videoMuted If peer&#x27;s video
       *   stream is muted.
       * @param {JSON|String} peerInfo.userData Peer&#x27;s custom user data.
       * @param {JSON} peerInfo.agent Peer&#x27;s browser agent.
       * @param {String} peerInfo.agent.name Peer&#x27;s browser agent name.
       * @param {Integer} peerInfo.agent.version Peer&#x27;s browser agent version.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.5.2
       */
      peerJoined: [],

      /**
       * Event fired when a peer information is updated.
       * @event peerUpdated
       * @param {String} peerId PeerId of the peer that had information updaed.
       * @param {JSON} peerInfo Peer&#x27;s information.
       * @param {JSON} peerInfo.settings Peer&#x27;s stream settings.
       * @param {Boolean|JSON} peerInfo.settings.audio Peer&#x27;s audio stream
       *   settings.
       * @param {Boolean} peerInfo.settings.audio.stereo If peer has stereo
       *   enabled or not.
       * @param {Boolean|JSON} peerInfo.settings.video Peer&#x27;s video stream
       *   settings.
       * @param {JSON} peerInfo.settings.video.resolution
       *   Peer&#x27;s video stream resolution [Rel: Skyway.VIDEO_RESOLUTION]
       * @param {Integer} peerInfo.settings.video.resolution.width
       *   Peer&#x27;s video stream resolution width.
       * @param {Integer} peerInfo.settings.video.resolution.height
       *   Peer&#x27;s video stream resolution height.
       * @param {Integer} peerInfo.settings.video.frameRate
       *   Peer&#x27;s video stream resolution minimum frame rate.
       * @param {JSON} peerInfo.mediaStatus Peer stream status.
       * @param {Boolean} peerInfo.mediaStatus.audioMuted If peer&#x27;s audio
       *   stream is muted.
       * @param {Boolean} peerInfo.mediaStatus.videoMuted If peer&#x27;s video
       *   stream is muted.
       * @param {JSON|String} peerInfo.userData Peer&#x27;s custom user data.
       * @param {JSON} peerInfo.agent Peer&#x27;s browser agent.
       * @param {String} peerInfo.agent.name Peer&#x27;s browser agent name.
       * @param {Integer} peerInfo.agent.version Peer&#x27;s browser agent version.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.5.2
       */
      peerUpdated: [],

      /**
       * Event fired when a peer leaves the room
       * @event peerLeft
       * @param {String} peerId PeerId of the peer that left.
       * @param {JSON} peerInfo Peer&#x27;s information.
       * @param {JSON} peerInfo.settings Peer&#x27;s stream settings.
       * @param {Boolean|JSON} peerInfo.settings.audio Peer&#x27;s audio stream
       *   settings.
       * @param {Boolean} peerInfo.settings.audio.stereo If peer has stereo
       *   enabled or not.
       * @param {Boolean|JSON} peerInfo.settings.video Peer&#x27;s video stream
       *   settings.
       * @param {JSON} peerInfo.settings.video.resolution
       *   Peer&#x27;s video stream resolution [Rel: Skyway.VIDEO_RESOLUTION]
       * @param {Integer} peerInfo.settings.video.resolution.width
       *   Peer&#x27;s video stream resolution width.
       * @param {Integer} peerInfo.settings.video.resolution.height
       *   Peer&#x27;s video stream resolution height.
       * @param {Integer} peerInfo.settings.video.frameRate
       *   Peer&#x27;s video stream resolution minimum frame rate.
       * @param {JSON} peerInfo.mediaStatus Peer stream status.
       * @param {Boolean} peerInfo.mediaStatus.audioMuted If peer&#x27;s audio
       *   stream is muted.
       * @param {Boolean} peerInfo.mediaStatus.videoMuted If peer&#x27;s video
       *   stream is muted.
       * @param {JSON|String} peerInfo.userData Peer&#x27;s custom user data.
       * @param {JSON} peerInfo.agent Peer&#x27;s browser agent.
       * @param {String} peerInfo.agent.name Peer&#x27;s browser agent name.
       * @param {Integer} peerInfo.agent.version Peer&#x27;s browser agent version.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.5.2
       */
      peerLeft: [],

      /**
       * TODO Event fired when a peer joins the room
       * @event presenceChanged
       * @param {JSON} users The list of users
       * @private
       * @deprecated
       * @since 0.1.0
       */
      presenceChanged: [],

      /**
       * Event fired when a remote stream has become available.
       * - This occurs after the user joins the room.
       * - This is changed from &lt;b&gt;addPeerStream&lt;/b&gt; event.
       * - Note that &lt;b&gt;addPeerStream&lt;/b&gt; is removed from the specs.
       * - There has been a documentation error whereby the stream it is
       *   supposed to be (stream, peerId, isSelf), but instead is received
       *   as (peerId, stream, isSelf) in 0.5.0.
       * @event incomingStream
       * @param {String} peerId PeerId of the peer that is sending the stream.
       * @param {Object} stream MediaStream object.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.4.0
       */
      incomingStream: [],

      /**
       * Event fired when a message being broadcasted is received.
       * - This is changed from &lt;b&gt;chatMessageReceived&lt;/b&gt;,
       *   &lt;b&gt;privateMessage&lt;/b&gt; and &lt;b&gt;publicMessage&lt;/b&gt; event.
       * - Note that &lt;b&gt;chatMessageReceived&lt;/b&gt;, &lt;b&gt;privateMessage&lt;/b&gt;
       *   and &lt;b&gt;publicMessage&lt;/b&gt; is removed from the specs.
       * @event incomingMessage
       * @param {JSON} message Message object that is received.
       * @param {JSON|String} message.content Data that is broadcasted.
       * @param {String} message.senderPeerId PeerId of the sender peer.
       * @param {String} message.targetPeerId PeerId that is specifically
       *   targeted to receive the message.
       * @param {Boolean} message.isPrivate Is data received a private message.
       * @param {Boolean} message.isDataChannel Is data received from a
       *   data channel.
       * @param {String} peerId PeerId of the sender peer.
       * @param {JSON} peerInfo Peer&#x27;s information.
       * @param {JSON} peerInfo.settings Peer&#x27;s stream settings.
       * @param {Boolean|JSON} peerInfo.settings.audio Peer&#x27;s audio stream
       *   settings.
       * @param {Boolean} peerInfo.settings.audio.stereo If peer has stereo
       *   enabled or not.
       * @param {Boolean|JSON} peerInfo.settings.video Peer&#x27;s video stream
       *   settings.
       * @param {JSON} peerInfo.settings.video.resolution
       *   Peer&#x27;s video stream resolution [Rel: Skyway.VIDEO_RESOLUTION]
       * @param {Integer} peerInfo.settings.video.resolution.width
       *   Peer&#x27;s video stream resolution width.
       * @param {Integer} peerInfo.settings.video.resolution.height
       *   Peer&#x27;s video stream resolution height.
       * @param {Integer} peerInfo.settings.video.frameRate
       *   Peer&#x27;s video stream resolution minimum frame rate.
       * @param {JSON} peerInfo.mediaStatus Peer stream status.
       * @param {Boolean} peerInfo.mediaStatus.audioMuted If peer&#x27;s audio
       *   stream is muted.
       * @param {Boolean} peerInfo.mediaStatus.videoMuted If peer&#x27;s video
       *   stream is muted.
       * @param {JSON|String} peerInfo.userData Peer&#x27;s custom user data.
       * @param {JSON} peerInfo.agent Peer&#x27;s browser agent.
       * @param {String} peerInfo.agent.name Peer&#x27;s browser agent name.
       * @param {Integer} peerInfo.agent.version Peer&#x27;s browser agent version.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.5.2
       */
      incomingMessage: [],

      /**
       * Event fired when connected to a room and the lock status has changed.
       * @event roomLock
       * @param {Boolean} isLocked Is the room locked.
       * @param {String} peerId PeerId of the peer that is locking/unlocking
       *   the room.
       * @param {JSON} peerInfo Peer&#x27;s information.
       * @param {JSON} peerInfo.settings Peer&#x27;s stream settings.
       * @param {Boolean|JSON} peerInfo.settings.audio Peer&#x27;s audio stream
       *   settings.
       * @param {Boolean} peerInfo.settings.audio.stereo If peer has stereo
       *   enabled or not.
       * @param {Boolean|JSON} peerInfo.settings.video Peer&#x27;s video stream
       *   settings.
       * @param {JSON} peerInfo.settings.video.resolution
       *   Peer&#x27;s video stream resolution [Rel: Skyway.VIDEO_RESOLUTION]
       * @param {Integer} peerInfo.settings.video.resolution.width
       *   Peer&#x27;s video stream resolution width.
       * @param {Integer} peerInfo.settings.video.resolution.height
       *   Peer&#x27;s video stream resolution height.
       * @param {Integer} peerInfo.settings.video.frameRate
       *   Peer&#x27;s video stream resolution minimum frame rate.
       * @param {JSON} peerInfo.mediaStatus Peer stream status.
       * @param {Boolean} peerInfo.mediaStatus.audioMuted If peer&#x27;s audio
       *   stream is muted.
       * @param {Boolean} peerInfo.mediaStatus.videoMuted If peer&#x27;s video
       *   stream is muted.
       * @param {JSON|String} peerInfo.userData Peer&#x27;s custom user data.
       * @param {JSON} peerInfo.agent Peer&#x27;s browser agent.
       * @param {String} peerInfo.agent.name Peer&#x27;s browser agent name.
       * @param {Integer} peerInfo.agent.version Peer&#x27;s browser agent version.
       * @param {Boolean} isSelf Is the peer self.
       * @since 0.5.2
       */
      roomLock: [],

      /**
       * Event fired when a peer&#x27;s datachannel state has changed.
       * @event dataChannelState
       * @param {String} state The datachannel state.
       *   [Rel: Skyway.DATA_CHANNEL_STATE]
       * @param {String} peerId PeerId of peer that has a datachannel
       *   state change.
       * @since 0.1.0
       */
      dataChannelState: [],

      /**
       * Event fired when a data transfer state has changed.
       * - Note that &lt;u&gt;transferInfo.data&lt;/u&gt; sends the blob data, and
       *   no longer a blob url.
       * @event dataTransferState
       * @param {String} state The data transfer state.
       *   [Rel: Skyway.DATA_TRANSFER_STATE]
       * @param {String} transferId TransferId of the data.
       * @param {String} peerId PeerId of the peer that has a data
       *   transfer state change.
       * @param {JSON} transferInfo Data transfer information.
       * @param {JSON} transferInfo.percentage The percetange of data being
       *   uploaded / downloaded.
       * @param {JSON} transferInfo.senderPeerId PeerId of the sender.
       * @param {JSON} transferInfo.data The blob data. See the
       *   [createObjectURL](https://developer.mozilla.org/en-US/docs/Web/API/URL.createObjectURL)
       *   method on how you can convert the blob to a download link.
       * @param {JSON} transferInfo.name Data name.
       * @param {JSON} transferInfo.size Data size.
       * @param {JSON} error The error object.
       * @param {String} error.message Error message thrown.
       * @param {String} error.transferType Is error from uploading or downloading.
       *   [Rel: Skyway.DATA_TRANSFER_TYPE]
       * @since 0.4.1
       */
      dataTransferState: [],

      /**
       * Event fired when the signaling server warns the user.
       * @event systemAction
       * @param {String} action The action that is required for
       *   the user to follow. [Rel: Skyway.SYSTEM_ACTION]
       * @param {String} message The reason for the action.
       * @param {String} reason The reason why the action is given.
       *   [Rel: Skyway.SYSTEM_ACTION_REASON]
       * @since 0.5.1
       */
      systemAction: []
    };
  }
  this.Skyway = Skyway;

  /************************* Debugging Methods ****************************/
  /**
   * Logs all the console information.
   * - TODO: Set all interface information.
   * @method _log
   * @param {String} logLevel The log level. [Rel: Skyway.LOG_LEVEL]
   * @param {JSON|String} message The console message.
   * @param {String} message.target The targetPeerId the message is targeted to.
   * @param {String} message.interface The interface the message is targeted to.
   * @param {Array|String} message.keys The events the message is targeted to.
   * @param {String} message.log The log message.
   * @param {Object|String} debugObject The console parameter string or object.
   * @private
   * @required
   * @since 0.5.2
   */
  Skyway.prototype._log = function(logLevel, message, debugObject) {
    var logOrders = { debug: 4, log: 3, info: 2, warn: 1, error: 0 };
    if (typeof logOrders[logLevel] !== &#x27;number&#x27;) {
      this._log(this.LOG_LEVEL.ERROR, {
        interface: &#x27;Log&#x27;,
        log: &#x27;Invalid log level provided. Provided log level: &#x27;
      }, logLevel);
      return;
    }
    if (logOrders[this._logLevel] &gt;= logOrders[logLevel]) {
      var outputLog = &#x27;SkywayJS&#x27;;
      if (typeof message === &#x27;object&#x27;) {
        outputLog += (message.target) ? &#x27; [&#x27; + message.target + &#x27;] -&#x27; : &#x27; -&#x27;;
        outputLog += (message.interface) ? &#x27; &lt;&lt;&#x27; + message.interface + &#x27;&gt;&gt;&#x27; : &#x27;&#x27;;
        if (message.keys) {
          outputLog += &#x27; &#x27;;
          if (typeof message.keys === &#x27;object&#x27;) {
            for (var i = 0; i &lt; message.keys.length; i++) {
              outputLog += &#x27;(&#x27; + message.keys[i] + &#x27;)&#x27;;
            }
          } else {
            outputLog += &#x27;(&#x27; + message.keys + &#x27;)&#x27;;
          }
        }
        outputLog += &#x27; &#x27; + message.log;
      } else {
        outputLog += &#x27; - &#x27; + message;
      }
      // Fallback to log if failure
      logLevel = (typeof console[logLevel] === &#x27;undefined&#x27;) ? this.LOG_LEVEL.TRACE : logLevel;
      if (this._enableDebugMode) {
        if (typeof debugObject !== &#x27;undefined&#x27;) {
          console[logLevel](outputLog, debugObject, this._getStack());
        } else {
          console[logLevel](outputLog, this._getStack());
        }
      } else {
        if (typeof debugObject !== &#x27;undefined&#x27;) {
          console[logLevel](outputLog, debugObject);
        } else {
          console[logLevel](outputLog);
        }
      }
    }
  };

  /**
   * Stack class of Skyway.
   * @property SkywayStack
   * @param {Array} stack The stack object.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype.SkywayStack = function (stack) {
    this.stack = stack;
  };

  /**
   * Stacks all the caller functions.
   * @author codeovertones.com
   * @method _getStack
   * @return {Object} SkywayStack object.
   * @private
   * @required
   * @since 0.5.2
   */
  Skyway.prototype._getStack = function() {
    var e = new Error(&#x27;SkywayStack&#x27;);
    var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, &#x27;&#x27;)
        .replace(/^\s+at\s+/gm, &#x27;&#x27;)
        .replace(/^Object.&lt;anonymous&gt;\s*\(/gm, &#x27;{anonymous}()@&#x27;)
        .split(&#x27;\n&#x27;);
    return new this.SkywayStack(stack);
  };

  /************************* REST Request Methods ****************************/
  /**
   * Gets information from api server.
   * @method _requestServerInfo
   * @param {String} method The http method.
   * @param {String} url The url to do a rest call.
   * @param {Function} callback The callback fired after Skyway
   *   receives a response from the api server.
   * @param {JSON} params HTTP Params
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._requestServerInfo = function(method, url, callback, params) {
    var self = this;
    // XDomainRequest is supported in IE8 - 9
    var useXDomainRequest = window.webrtcDetectedBrowser === &#x27;IE&#x27; &amp;&amp;
      (window.webrtcDetectedVersion === 9 || window.webrtcDetectedVersion === 8) &amp;&amp;
      typeof window.XDomainRequest === &#x27;function&#x27;;
    var xhr;

    if (useXDomainRequest) {
      self._log(self.LOG_LEVEL.DEBUG, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Using XDomainRequest. XMLHttpRequest is now XDomainRequest&#x27;
      }, {
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion
      });
      xhr = new XDomainRequest();
      xhr.setContentType = function (contentType) {
        xhr.contentType = contentType;
      };
    } else {
      self._log(self.LOG_LEVEL.DEBUG, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Using XMLHttpRequest&#x27;
      }, {
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion
      });
      xhr = new window.XMLHttpRequest();
      xhr.setContentType = function (contentType) {
        xhr.setRequestHeader(&#x27;Content-type&#x27;, contentType);
      };
    }

    xhr.onload = function () {
      xhr.response = xhr.responseText || xhr.response;
      xhr.status = xhr.status || 200;
      self._log(self.LOG_LEVEL.DEBUG, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Received sessions parameters&#x27;
      }, JSON.parse(xhr.response || &#x27;{}&#x27;));
      callback(xhr.status, JSON.parse(xhr.response || &#x27;{}&#x27;));
    };

    xhr.onerror = function () {
      self._log(self.LOG_LEVEL.ERROR, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Failed retrieving information: &#x27;
      }, { status: xhr.status });
    };

    xhr.onprogress = function () {
      self._log(self.LOG_LEVEL.DEBUG, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Retrieving information and config from webserver. Url: &#x27;
      }, url);
      self._log(self.LOG_LEVEL.DEBUG, {
        interface: &#x27;XMLHttpRequest&#x27;,
        keys: method,
        log: &#x27;Provided parameters: &#x27;
      }, params);
    };

    xhr.open(method, url, true);
    if (params) {
      xhr.setContentType(&#x27;application/json;charset=UTF-8&#x27;);
      xhr.send(JSON.stringify(params));
    } else {
      xhr.send();
    }
  };

  /**
   * Parse the information received from the api server.
   * @method _parseInfo
   * @param {JSON} info The parsed information from the server.
   * @trigger readyStateChange
   * @private
   * @required
   * @since 0.5.2
   */
  Skyway.prototype._parseInfo = function(info) {
    this._log(this.LOG_LEVEL.TRACE, &#x27;Parsing parameter from server&#x27;, info);
    if (!info.pc_constraints &amp;&amp; !info.offer_constraints) {
      this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.ERROR, {
        status: 200,
        content: info.info,
        errorCode: info.error
      });
      return;
    }

    this._log(this.LOG_LEVEL.DEBUG, &#x27;Peer connection constraints: &#x27;, info.pc_constraints);
    this._log(this.LOG_LEVEL.DEBUG, &#x27;Offer constraints: &#x27;, info.offer_constraints);

    this._key = info.cid;
    this._apiKeyOwner = info.apiOwner;
    this._signalingServer = info.ipSigserver;
    this._user = {
      uid: info.username,
      token: info.userCred,
      timeStamp: info.timeStamp,
      streams: [],
      info: {}
    };
    this._room = {
      id: info.room_key,
      token: info.roomCred,
      startDateTime: info.start,
      duration: info.len,
      connection: {
        peerConstraints: JSON.parse(info.pc_constraints),
        peerConfig: null,
        offerConstraints: JSON.parse(info.offer_constraints),
        sdpConstraints: {
          mandatory: {
            OfferToReceiveAudio: true,
            OfferToReceiveVideo: true
          }
        },
        mediaConstraints: JSON.parse(info.media_constraints)
      }
    };
    // use default bandwidth and media resolution provided by server
    this._streamSettings.bandwidth = info.bandwidth;
    this._readyState = 2;
    this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.COMPLETED);
    this._log(this.LOG_LEVEL.INFO, &#x27;Parsed parameters from webserver. &#x27; +
      &#x27;Ready for web-realtime communication&#x27;);
  };

  /**
   * Start the loading of information from the api server.
   * @method _loadInfo
   * @trigger readyStateChange
   * @private
   * @required
   * @since 0.5.2
   */
  Skyway.prototype._loadInfo = function() {
    var self = this;
    if (!window.io) {
      self._log(self.LOG_LEVEL.ERROR, &#x27;Socket.io not loaded. Please load &#x27; +
        &#x27;socket.io&#x27;);
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: null,
        content: &#x27;Socket.io not found&#x27;,
        errorCode: self.READY_STATE_CHANGE_ERROR.NO_SOCKET_IO
      });
      return;
    }
    if (!window.XMLHttpRequest) {
      self._log(self.LOG_LEVEL.ERROR, &#x27;XMLHttpRequest not supported. &#x27; +
        &#x27;Please upgrade your browser&#x27;);
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: null,
        content: &#x27;XMLHttpRequest not available&#x27;,
        errorCode: self.READY_STATE_CHANGE_ERROR.NO_XMLHTTPREQUEST_SUPPORT
      });
      return;
    }
    if (!window.RTCPeerConnection) {
      self._log(self.LOG_LEVEL.ERROR, &#x27;WebRTC not supported. Please upgrade &#x27; +
        &#x27;your browser&#x27;);
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: null,
        content: &#x27;WebRTC not available&#x27;,
        errorCode: self.READY_STATE_CHANGE_ERROR.NO_WEBRTC_SUPPORT
      });
      return;
    }
    if (!self._path) {
      self._log(self.LOG_LEVEL.ERROR, &#x27;Skyway is not initialised. Please call &#x27; +
        &#x27;init() first&#x27;);
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: null,
        content: &#x27;No API Path is found&#x27;,
        errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH
      });
      return;
    }
    self._readyState = 1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.LOADING);
    self._requestServerInfo(&#x27;GET&#x27;, self._path, function(status, response) {
      if (status !== 200) {
        // 403 - Room is locked
        // 401 - API Not authorized
        // 402 - run out of credits
        var errorMessage = &#x27;XMLHttpRequest status not OK\nStatus was: &#x27; + status;
        self._readyState = 0;
        self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
          status: status,
          content: (response) ? (response.info || errorMessage) : errorMessage,
          errorCode: response.error ||
            self.READY_STATE_CHANGE_ERROR.INVALID_XMLHTTPREQUEST_STATUS
        });
        return;
      }
      self._parseInfo(response);
    });
  };

  /**
   * Initialize Skyway to retrieve new connection information bbasd on options.
   * @method _initSelectedRoom
   * @param {String} room The room to connect to.
   * @param {Function} callback The callback fired once Skyway is re-initialized.
   * @trigger readyStateChange
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._initSelectedRoom = function(room, callback) {
    var self = this;
    if (typeof room === &#x27;function&#x27; || typeof room === &#x27;undefined&#x27;) {
      self._log(self.LOG_LEVEL.ERROR, &#x27;Invalid room provided. Room: &#x27;, room);
      return;
    }
    var defaultRoom = self._defaultRoom;
    var initOptions = {
      roomServer: self._roomServer,
      defaultRoom: room || defaultRoom,
      apiKey: self._apiKey,
      region: self._serverRegion,
      dataChannel: self._enableDataChannel,
      iceTrickle: self._enableIceTrickle
    };
    if (self._roomCredentials) {
      initOptions.credentials = {
        credentials: self._roomCredentials,
        duration: self._roomDuration,
        startDateTime: self._roomStart
      };
    }
    self.init(initOptions);
    self._defaultRoom = defaultRoom;
    var checkReadyState = setInterval(function () {
      if (self._readyState === self.READY_STATE_CHANGE.COMPLETED) {
        clearInterval(checkReadyState);
        callback();
      }
    }, 100);
  };

  /************************* Event Methods ****************************/
  /**
   * Trigger all the callbacks associated with an event.
   * - Note that extra arguments can be passed to the callback which
   *   extra argument can be expected by callback is documented by each event.
   * @method _trigger
   * @param {String} eventName The Skyway event.
   * @for Skyway
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._trigger = function(eventName) {
    var args = Array.prototype.slice.call(arguments),
      arr = this._EVENTS[eventName];
    args.shift();
    if (arr) {
      for (var e in arr) {
        if (arr.hasOwnProperty(e)) {
          try {
            if (arr[e].apply(this, args) === false) {
              break;
            }
          } catch(error) {
            this._log(this.LOG_LEVEL.ERROR, {
              interface: &#x27;Event&#x27;,
              keys: eventName,
              log: &#x27;Exception occurred in event: &#x27;
            }, error);
          }
        }
      }
    }
    this._log(this.LOG_LEVEL.TRACE, {
      interface: &#x27;Event&#x27;,
      keys: eventName,
      log: &#x27;Event is triggered&#x27;
    });
  };

  /**
   * Access to user&#x27;s MediaStream is successful.
   * @method _onUserMediaSuccess
   * @param {MediaStream} stream MediaStream object.
   * @trigger mediaAccessSuccess
   * @private
   * @since 0.3.0
   */
  Skyway.prototype._onUserMediaSuccess = function(stream) {
    var self = this;
    self._log(self.LOG_LEVEL.TRACE, {
      interface: &#x27;MediaStream&#x27;,
      keys: stream.id,
      log: &#x27;User has granted access to local media&#x27;
    }, stream);
    self._trigger(&#x27;mediaAccessSuccess&#x27;, stream);
    var checkReadyState = setInterval(function () {
      if (self._readyState === self.READY_STATE_CHANGE.COMPLETED) {
        clearInterval(checkReadyState);
        self._user.streams[stream.id] = stream;
        self._user.streams[stream.id].active = true;
        var checkIfUserInRoom = setInterval(function () {
          if (self._inRoom) {
            clearInterval(checkIfUserInRoom);
            self._trigger(&#x27;incomingStream&#x27;, self._user.sid, stream, true);
          }
        }, 500);
      }
    }, 500);
  };

  /**
   * Access to user&#x27;s MediaStream failed.
   * @method _onUserMediaError
   * @param {Object} error Error object that was thrown.
   * @trigger mediaAccessFailure
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._onUserMediaError = function(error) {
    this._log(this.LOG_LEVEL.ERROR, {
      interface: &#x27;MediaStream&#x27;,
      log: &#x27;Failed retrieving stream: &#x27;
    }, error);
    this._trigger(&#x27;mediaAccessError&#x27;, error);
  };

  /**
   * The remote peer advertised streams, that we are forwarding to the app. This is part
   * of the peerConnection&#x27;s addRemoteDescription() API&#x27;s callback.
   * @method _onRemoteStreamAdded
   * @param {String} targetMid PeerId of the peer that has remote stream to send.
   * @param {Event}  event This is provided directly by the peerconnection API.
   * @trigger incomingStream
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._onRemoteStreamAdded = function(targetMid, event) {
    if(targetMid !== &#x27;MCU&#x27;) {
      if (!this._peerInformations[targetMid]) {
        this._log(this.LOG_LEVEL.ERROR, {
          target: targetMid,
          interface: &#x27;MediaStream&#x27;,
          keys: event.stream.id,
          log: &#x27;Received remote stream when peer is not connected. &#x27; +
            &#x27;Ignoring stream -&gt; &#x27;
        }, event.stream);
        return;
      }
      if (!this._peerInformations[targetMid].settings.audio &amp;&amp;
        !this._peerInformations[targetMid].settings.video) {
        this._log(this.LOG_LEVEL.TRACE, {
          target: targetMid,
          interface: &#x27;MediaStream&#x27;,
          keys: event.stream.id,
          log: &#x27;Receive remote stream but ignoring stream as it is empty -&gt; &#x27;
        }, event.stream);
        return;
      }
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        interface: &#x27;MediaStream&#x27;,
        keys: event.stream.id,
        log: &#x27;Received remote stream -&gt; &#x27;
      }, event.stream);
      this._trigger(&#x27;incomingStream&#x27;, targetMid, event.stream, false);
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        log: &#x27;MCU is listening&#x27;
      });
    }
  };

  /**
   * A candidate has just been generated (ICE gathering) and will be sent to the peer.
   * Part of connection establishment.
   * @method _onIceCandidate
   * @param {String} targetMid
   * @param {Event} event This is provided directly by the peerconnection API.
   * @trigger candidateGenerationState
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._onIceCandidate = function(targetMid, event) {
    if (event.candidate) {
      if (this._enableIceTrickle) {
        var messageCan = event.candidate.candidate.split(&#x27; &#x27;);
        var candidateType = messageCan[7];
        this._log(this.LOG_LEVEL.DEBUG, {
          target: targetMid,
          interface: &#x27;RTCIceCandidate&#x27;,
          log: &#x27;Created and sending &#x27; + candidateType + &#x27; candidate: &#x27;
        }, event);
        this._sendChannelMessage({
          type: this._SIG_MESSAGE_TYPE.CANDIDATE,
          label: event.candidate.sdpMLineIndex,
          id: event.candidate.sdpMid,
          candidate: event.candidate.candidate,
          mid: this._user.sid,
          target: targetMid,
          rid: this._room.id
        });
      }
    } else {
      this._log(this.LOG_LEVEL.DEBUG, {
        target: targetMid,
        interface: &#x27;RTCIceCandidate&#x27;,
        log: &#x27;End of gathering&#x27;
      });
      this._trigger(&#x27;candidateGenerationState&#x27;, this.CANDIDATE_GENERATION_STATE.COMPLETED,
        targetMid);
      // Disable Ice trickle option
      if (!this._enableIceTrickle) {
        var sessionDescription = this._peerConnections[targetMid].localDescription;
        this._sendChannelMessage({
          type: sessionDescription.type,
          sdp: sessionDescription.sdp,
          mid: this._user.sid,
          agent: window.webrtcDetectedBrowser,
          target: targetMid,
          rid: this._room.id
        });
      }
    }
  };

  /************************* Socket Message Handler Methods ****************************/
  /**
   * Handles everu incoming signaling message received.
   * - If it&#x27;s a SIG_TYPE.GROUP message, break them down to single messages
   *   and let {{#crossLink &quot;Skyway/_processSingleMessage:method&quot;}}
   *   _processSingleMessage(){{/crossLink}} to handle them.
   * @method _processSigMessage
   * @param {String} messageString The message object stringified received.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._processSigMessage = function(messageString) {
    var message = JSON.parse(messageString);
    if (message.type === this._SIG_MESSAGE_TYPE.GROUP) {
      this._log(this.LOG_LEVEL.DEBUG, &#x27;Bundle of &#x27; + message.lists.length + &#x27; messages&#x27;);
      for (var i = 0; i &lt; message.lists.length; i++) {
        this._processSingleMessage(message.lists[i]);
      }
    } else {
      this._processSingleMessage(message);
    }
  };

  /**
   * Handles the single signaling message received.
   * @method _processingSingleMessage
   * @param {JSON} message The message object received.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._processSingleMessage = function(message) {
    this._trigger(&#x27;channelMessage&#x27;, message);
    var origin = message.mid;
    if (!origin || origin === this._user.sid) {
      origin = &#x27;Server&#x27;;
    }
    this._log(this.LOG_LEVEL.DEBUG, {
      target: origin,
      log: &#x27;Recevied from peer -&gt; &#x27;
    }, message.type);
    if (message.mid === this._user.sid &amp;&amp;
      message.type !== this._SIG_MESSAGE_TYPE.REDIRECT &amp;&amp;
      message.type !== this._SIG_MESSAGE_TYPE.IN_ROOM) {
      this._log(this.LOG_LEVEL.DEBUG, {
        target: origin,
        log: &#x27;Ignoring message -&gt; &#x27;
      }, message.type);
      return;
    }
    switch (message.type) {
    //--- BASIC API Messages ----
    case this._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE:
      this._publicMessageHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.PRIVATE_MESSAGE:
      this._privateMessageHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.IN_ROOM:
      this._inRoomHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.ENTER:
      this._enterHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.WELCOME:
      this._welcomeHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.OFFER:
      this._offerHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.ANSWER:
      this._answerHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.CANDIDATE:
      this._candidateHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.BYE:
      this._byeHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.REDIRECT:
      this._redirectHandler(message);
      break;
      //--- ADVANCED API Messages ----
    case this._SIG_MESSAGE_TYPE.UPDATE_USER:
      this._updateUserEventHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.MUTE_VIDEO:
      this._muteVideoEventHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.MUTE_AUDIO:
      this._muteAudioEventHandler(message);
      break;
    case this._SIG_MESSAGE_TYPE.ROOM_LOCK:
      this._roomLockEventHandler(message);
      break;
    default:
      this._log(this.LOG_LEVEL.ERROR, {
        target: message.mid,
        log: &#x27;Unsupported message -&gt; &#x27;
      }, message.type);
      break;
    }
  };

  /**
   * Signaling server sends a redirect message.
   * - SIG_TYPE: REDIRECT
   * - This occurs when the signaling server is warning us or wanting
   *   to move us out when the peer sends too much messages at the
   *   same tme.
   * @method _redirectHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.info The reason for this action.
   * @param {String} message.action The action to work on.
   *   [Rel: Skyway.SYSTEM_ACTION]
   * @param {String} message.reason The reason of why the action is worked upon.
   *   [Rel: Skyway.SYSTEM_ACTION_REASON]
   * @param {String} message.type The type of message received.
   * @trigger systemAction
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._redirectHandler = function(message) {
    this._log(this.LOG_LEVEL.TRACE, {
      target: &#x27;Server&#x27;,
      keys: message.type,
      log: &#x27;System action warning: &#x27;
    }, {
      message: message.info,
      reason: message.reason,
      action: message.action
    });
    this._trigger(&#x27;systemAction&#x27;, message.action, message.info, message.reason);
  };

  /**
   * Signaling server sends a updateUserEvent message.
   * - SIG_TYPE: UPDATE_USER
   * - This occurs when a peer&#x27;s custom user data is updated.
   * @method _updateUserEventHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the
   *   updated event.
   * @param {JSON|String} message.userData The peer&#x27;s user data.
   * @param {String} message.type The type of message received.
   * @trigger peerUpdated
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._updateUserEventHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Peer updated userData: &#x27;
    }, message.userData);
    if (this._peerInformations[targetMid]) {
      this._peerInformations[targetMid].userData = message.userData || {};
      this._trigger(&#x27;peerUpdated&#x27;, targetMid,
        this._peerInformations[targetMid], false);
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Peer does not have any user information&#x27;
      });
    }
  };

  /**
   * Signaling server sends a roomLockEvent message.
   * - SIG_TYPE: ROOM_LOCK
   * - This occurs when a room lock status has changed.
   * @method _roomLockEventHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the
   *   updated room lock status.
   * @param {String} message.lock If room is locked or not.
   * @param {String} message.type The type of message received.
   * @trigger roomLock
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._roomLockEventHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Room lock status: &#x27;
    }, message.lock);
    this._trigger(&#x27;roomLock&#x27;, message.lock, targetMid,
      this._peerInformations[targetMid], false);
  };

  /**
   * Signaling server sends a muteAudioEvent message.
   * - SIG_TYPE: MUTE_AUDIO
   * - This occurs when a peer&#x27;s audio stream muted
   *   status has changed.
   * @method _muteAudioEventHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending
   *   their own updated audio stream status.
   * @param {String} message.muted If audio stream is muted or not.
   * @param {String} message.type The type of message received.
   * @trigger peerUpdated
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._muteAudioEventHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Peer\&#x27;s audio muted: &#x27;
    }, message.muted);
    if (this._peerInformations[targetMid]) {
      this._peerInformations[targetMid].mediaStatus.audioMuted = message.muted;
      this._trigger(&#x27;peerUpdated&#x27;, targetMid,
        this._peerInformations[targetMid], false);
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Peer does not have any user information&#x27;
      });
    }
  };

  /**
   * Signaling server sends a muteVideoEvent message.
   * - SIG_TYPE: MUTE_VIDEO
   * - This occurs when a peer&#x27;s video stream muted
   *   status has changed.
   * @method _muteVideoEventHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending
   *   their own updated video streams status.
   * @param {String} message.muted If video stream is muted or not.
   * @param {String} message.type The type of message received.
   * @trigger peerUpdated
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._muteVideoEventHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Peer\&#x27;s video muted: &#x27;
    }, message.muted);
    if (this._peerInformations[targetMid]) {
      this._peerInformations[targetMid].mediaStatus.videoMuted = message.muted;
      this._trigger(&#x27;peerUpdated&#x27;, targetMid,
        this._peerInformations[targetMid], false);
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Peer does not have any user information&#x27;
      });
    }
  };

  /**
   * Signaling server sends a bye message.
   * - SIG_TYPE: BYE
   * - This occurs when a peer left the room.
   * @method _byeHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that has left the room.
   * @param {String} message.type The type of message received.
   * @trigger peerLeft
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._byeHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Peer has left the room&#x27;
    });
    this._removePeer(targetMid);
  };

  /**
   * Signaling server sends a privateMessage message.
   * - SIG_TYPE: PRIVATE_MESSAGE
   * - This occurs when a peer sends private message to user.
   * @method _privateMessageHandler
   * @param {JSON} message The message object received.
   * @param {JSON|String} message.data The data received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.cid CredentialId of the room.
   * @param {String} message.mid PeerId of the peer that is sending a private
   *   broadcast message.
   * @param {String} message.type The type of message received.
   * @trigger privateMessage
   * @private
   * @since 0.4.0
   */
  Skyway.prototype._privateMessageHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received private message from peer: &#x27;
    }, message.data);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message.data,
      isPrivate: true,
      targetPeerId: message.target, // is not null if there&#x27;s user
      isDataChannel: false,
      senderPeerId: targetMid
    }, targetMid, this._peerInformations[targetMid], false);
  };

  /**
   * Signaling server sends a publicMessage message.
   * - SIG_TYPE: PUBLIC_MESSAGE
   * - This occurs when a peer broadcasts a public message to
   *   all connected peers.
   * @method _publicMessageHandler
   * @param {JSON} message The message object received.
   * @param {JSON|String} message.data The data broadcasted
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.cid CredentialId of the room.
   * @param {String} message.mid PeerId of the peer that is sending a private
   *   broadcast message.
   * @param {String} message.type The type of message received.
   * @trigger publicMessage
   * @private
   * @since 0.4.0
   */
  Skyway.prototype._publicMessageHandler = function(message) {
    var targetMid = message.mid;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received public message from peer: &#x27;
    }, message.data);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message.data,
      isPrivate: false,
      targetPeerId: null, // is not null if there&#x27;s user
      isDataChannel: false,
      senderPeerId: targetMid
    }, targetMid, this._peerInformations[targetMid], false);
  };

  /**
   * Signaling server sends an inRoom message.
   * - SIG_TYPE: IN_ROOM
   * - This occurs the user has joined the room.
   * @method _inRoomHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.sid PeerId of self.
   * @param {String} message.mid PeerId of the peer that is
   *   sending the joinRoom message.
   * @param {JSON} message.pc_config The peerconnection configuration.
   * @param {String} message.type The type of message received.
   * @trigger peerJoined
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._inRoomHandler = function(message) {
    var self = this;
    self._log(self.LOG_LEVEL.TRACE, {
      target: &#x27;Server&#x27;,
      keys: message.type,
      log: &#x27;User is now in the room and functionalities are &#x27; +
        &#x27;now available. Config received: &#x27;
    }, message.pc_config);
    self._room.connection.peerConfig = self._setFirefoxIceServers(message.pc_config);
    self._inRoom = true;
    self._user.sid = message.sid;
    self._trigger(&#x27;peerJoined&#x27;, self._user.sid, self._user.info, true);
    self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ENTER, self._user.sid);
    // NOTE ALEX: should we wait for local streams?
    // or just go with what we have (if no stream, then one way?)
    // do we hardcode the logic here, or give the flexibility?
    // It would be better to separate, do we could choose with whom
    // we want to communicate, instead of connecting automatically to all.
    self._sendChannelMessage({
      type: self._SIG_MESSAGE_TYPE.ENTER,
      mid: self._user.sid,
      rid: self._room.id,
      agent: window.webrtcDetectedBrowser,
      version: window.webrtcDetectedVersion,
      userInfo: self._user.info
    });
  };

  /**
   * Signaling server sends a enter message.
   * - SIG_TYPE: ENTER
   * - This occurs when a peer just entered the room.
   * - If we don&#x27;t have a connection with the peer, send a welcome.
   * @method _enterHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the enter shake.
   * @param {String} message.agent Peer&#x27;s browser agent.
   * @param {String} message.version Peer&#x27;s browser version.
   * @param {String} message.userInfo Peer&#x27;s user information.
   * @param {JSON} message.userInfo.settings Peer&#x27;s stream settings
   * @param {Boolean|JSON} message.userInfo.settings.audio
   * @param {Boolean} message.userInfo.settings.audio.stereo
   * @param {Boolean|JSON} message.userInfo.settings.video
   * @param {JSON} message.userInfo.settings.video.resolution [Rel: Skyway.VIDEO_RESOLUTION]
   * @param {Integer} message.userInfo.settings.video.resolution.width
   * @param {Integer} message.userInfo.settings.video.resolution.height
   * @param {Integer} message.userInfo.settings.video.frameRate
   * @param {JSON} message.userInfo.mediaStatus Peer stream status.
   * @param {Boolean} message.userInfo.mediaStatus.audioMuted If peer&#x27;s audio stream is muted.
   * @param {Boolean} message.userInfo.mediaStatus.videoMuted If peer&#x27;s video stream is muted.
   * @param {String|JSON} message.userInfo.userData Peer custom data.
   * @param {String} message.type The type of message received.
   * @trigger handshakeProgress, peerJoined
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._enterHandler = function(message) {
    var self = this;
    var targetMid = message.mid;
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Incoming peer have initiated handshake. Peer\&#x27;s information: &#x27;
    }, message.userInfo);
    // need to check entered user is new or not.
    // peerInformations because it takes a sequence before creating the
    // peerconnection object. peerInformations are stored at the start of the
    // handshake, so user knows if there is a peer already.
    if (self._peerInformations[targetMid]) {
      // NOTE ALEX: and if we already have a connection when the peer enter,
      // what should we do? what are the possible use case?
      self._log(self.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Ignoring message as peer is already added&#x27;
      });
      return;
    }
    // add peer
    self._addPeer(targetMid, {
      agent: message.agent,
      version: message.version
    }, false);
    if (targetMid !== &#x27;MCU&#x27;) {
      self._trigger(&#x27;peerJoined&#x27;, targetMid, message.userInfo, false);
      self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ENTER, targetMid);
      self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.WELCOME, targetMid);
      self._peerInformations[targetMid] = message.userInfo || {};
      self._peerInformations[targetMid].agent = {
        name: message.agent,
        version: message.version
      };
    } else {
      self._log(self.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: message.type,
        log: &#x27;MCU has joined&#x27;
      }, message.userInfo);
    }
    var weight = (new Date()).valueOf();
    self._peerHSPriorities[targetMid] = weight;
    self._sendChannelMessage({
      type: self._SIG_MESSAGE_TYPE.WELCOME,
      mid: self._user.sid,
      rid: self._room.id,
      agent: window.webrtcDetectedBrowser,
      version: window.webrtcDetectedVersion,
      userInfo: self._user.info,
      target: targetMid,
      weight: weight
    });
  };

  /**
   * Signaling server sends a welcome message.
   * - SIG_TYPE: WELCOME
   * - This occurs when we&#x27;ve just received a welcome.
   * - If there is no existing connection with this peer,
   *   create one, then set the remotedescription and answer.
   * @method _welcomeHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the welcome shake.
   * @param {Boolean} message.receiveOnly Peer to receive only
   * @param {Boolean} message.enableIceTrickle Option to enable Ice trickle or not
   * @param {Boolean} message.enableDataChannel Option to enable DataChannel or not
   * @param {JSON} message.userInfo Peer Skyway._user.info data.
   * @param {JSON} message.userInfo.settings Peer stream settings
   * @param {Boolean|JSON} message.userInfo.settings.audio
   * @param {Boolean} message.userInfo.settings.audio.stereo
   * @param {Boolean|JSON} message.userInfo.settings.video
   * @param {JSON} message.userInfo.settings.video.resolution [Rel: Skyway.VIDEO_RESOLUTION]
   * @param {Integer} message.userInfo.settings.video.resolution.width
   * @param {Integer} message.userInfo.settings.video.resolution.height
   * @param {Integer} message.userInfo.settings.video.frameRate
   * @param {JSON} message.userInfo.mediaStatus Peer stream status.
   * @param {Boolean} message.userInfo.mediaStatus.audioMuted If Peer&#x27;s Audio stream is muted.
   * @param {Boolean} message.userInfo.mediaStatus.videoMuted If Peer&#x27;s Video stream is muted.
   * @param {String|JSON} message.userInfo.userData Peer custom data
   * @param {String} message.agent Browser agent.
   * @param {String} message.version Browser version.
   * @param {String} message.target PeerId of the peer targeted to receieve this message.
   * @param {Integer} message.weight The weight of the message.
   * @param {String} message.type The type of message received.
   * @trigger handshakeProgress, peerJoined
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._welcomeHandler = function(message) {
    var targetMid = message.mid;
    var restartConn = false;
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received peer\&#x27;s response to handshake initiation. &#x27; +
        &#x27;Peer\&#x27;s information: &#x27;
    }, message.userInfo);
    if (this._peerConnections[targetMid]) {
      if (!this._peerConnections[targetMid].setOffer) {
        if (message.weight &lt; 0) {
          restartConn = true;
          this._log(this.LOG_LEVEL.TRACE, {
            target: targetMid,
            keys: message.type,
            log: &#x27;Peer\&#x27;s weight is lower than 0. Proceeding with offer&#x27;
          }, message.weight);
        } else if (this._peerHSPriorities[targetMid] &gt; message.weight) {
          restartConn = true;
          this._log(this.LOG_LEVEL.TRACE, {
            target: targetMid,
            keys: message.type,
            log: &#x27;User\&#x27;s generated weight is higher than peer\&#x27;s. &#x27; +
              &#x27;Proceeding with offer&#x27;
          }, this._peerHSPriorities[targetMid] + &#x27; &gt; &#x27; + message.weight);
        } else {
          this._log(this.LOG_LEVEL.TRACE, {
            target: targetMid,
            keys: message.type,
            log: &#x27;User\&#x27;s generated weight is lesser than peer\&#x27;s. &#x27; +
              &#x27;Ignoring message&#x27;
          }, this._peerHSPriorities[targetMid] + &#x27; &lt; &#x27; + message.weight);
          return;
        }
      } else {
        this._log(this.LOG_LEVEL.WARN, {
          target: targetMid,
          keys: message.type,
          log: &#x27;Ignoring message as peer is already added&#x27;
        });
        return;
      }
    }
    message.agent = (!message.agent) ? &#x27;chrome&#x27; : message.agent;
    this._enableIceTrickle = (typeof message.enableIceTrickle === &#x27;boolean&#x27;) ?
      message.enableIceTrickle : this._enableIceTrickle;
    this._enableDataChannel = (typeof message.enableDataChannel === &#x27;boolean&#x27;) ?
      message.enableDataChannel : this._enableDataChannel;
    if (!this._peerInformations[targetMid]) {
      if (targetMid !== &#x27;MCU&#x27;) {
        this._peerInformations[targetMid] = message.userInfo;
        this._peerInformations[targetMid].agent = {
          name: message.agent,
          version: message.version
        };
        this._trigger(&#x27;peerJoined&#x27;, targetMid, message.userInfo, false);
        this._trigger(&#x27;handshakeProgress&#x27;, this.HANDSHAKE_PROGRESS.WELCOME, targetMid);
      } else {
        this._log(this.LOG_LEVEL.TRACE, {
          target: targetMid,
          keys: message.type,
          log: &#x27;MCU has &#x27; + ((message.weight &gt; -1) ? &#x27;joined and &#x27; : &#x27;&#x27;) + &#x27; responded&#x27;
        });
      }
    }
    this._addPeer(targetMid, {
      agent: message.agent,
      version: message.version
    }, true, restartConn, message.receiveOnly);
  };

  /**
   * Signaling server sends an offer message.
   * - SIG_TYPE: OFFER
   * - This occurs when we&#x27;ve just received an offer.
   * - If there is no existing connection with this peer, create one,
   *   then set the remotedescription and answer.
   * @method _offerHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the offer shake.
   * @param {String} message.sdp Offer sessionDescription
   * @param {String} message.type The type of message received.
   * @trigger handshakeProgress
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._offerHandler = function(message) {
    var self = this;
    var targetMid = message.mid;
    var pc = self._peerConnections[targetMid];
    if (!pc) {
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Peer connection object not found. Unable to setRemoteDescription for offer&#x27;
      });
      return;
    }
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received offer from peer. Session description: &#x27;
    }, message.sdp);
    self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.OFFER, targetMid);
    var offer = new window.RTCSessionDescription(message);
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      interface: &#x27;RTCSessionDescription&#x27;,
      keys: message.type,
      log: &#x27;Session description object created&#x27;
    }, offer);

    pc.setRemoteDescription(new window.RTCSessionDescription(offer), function() {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Remote description set&#x27;
      });
      pc.setOffer = &#x27;remote&#x27;;
      self._addIceCandidateFromQueue(targetMid);
      self._doAnswer(targetMid);
    }, function(error) {
      self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Failed setting remote description: &#x27;
      }, error);
    });
  };

  /**
   * Signaling server sends a candidate message.
   * - SIG_TYPE: CANDIDATE
   * - This occurs when a peer sends an ice candidate.
   * @method _candidateHandler
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.mid PeerId of the peer that is sending the
   *   offer shake.
   * @param {String} message.sdp Offer sessionDescription.
   * @param {String} message.target PeerId that is specifically
   *   targeted to receive the message.
   * @param {String} message.id Peer&#x27;s ICE candidate id.
   * @param {String} message.candidate Peer&#x27;s ICE candidate object.
   * @param {String} message.label Peer&#x27;s ICE candidate label.
   * @param {String} message.type The type of message received.
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._candidateHandler = function(message) {
    var targetMid = message.mid;
    var pc = this._peerConnections[targetMid];
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received candidate from peer. Candidate config: &#x27;
    }, {
      sdp: message.sdp,
      target: message.target,
      candidate: message.candidate,
      label: message.label
    });
    // create ice candidate object
    var messageCan = message.candidate.split(&#x27; &#x27;);
    var canType = messageCan[7];
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Candidate type: &#x27;
    }, canType);
    // if (canType !== &#x27;relay&#x27; &amp;&amp; canType !== &#x27;srflx&#x27;) {
    // trace(&#x27;Skipping non relay and non srflx candidates.&#x27;);
    var index = message.label;
    var candidate = new window.RTCIceCandidate({
      sdpMLineIndex: index,
      candidate: message.candidate
    });
    if (pc) {
      /*if (pc.iceConnectionState === this.ICE_CONNECTION_STATE.CONNECTED) {
        this._log(this.LOG_LEVEL.DEBUG, {
          target: targetMid,
          log: &#x27;Received but not adding Candidate as we are already connected to this peer&#x27;
        });
        return;
      }*/
      // set queue before ice candidate cannot be added before setRemoteDescription.
      // this will cause a black screen of media stream
      if ((pc.setOffer === &#x27;local&#x27; &amp;&amp; pc.setAnswer === &#x27;remote&#x27;) ||
        (pc.setAnswer === &#x27;local&#x27; &amp;&amp; pc.setOffer === &#x27;remote&#x27;)) {
        pc.addIceCandidate(candidate);
        // NOTE ALEX: not implemented in chrome yet, need to wait
        // function () { trace(&#x27;ICE  -  addIceCandidate Succesfull. &#x27;); },
        // function (error) { trace(&#x27;ICE  - AddIceCandidate Failed: &#x27; + error); }
        //);
        this._log(this.LOG_LEVEL.DEBUG, {
          target: targetMid,
          interface: &#x27;RTCIceCandidate&#x27;,
          keys: message.type,
          log: &#x27;Added candidate&#x27;
        }, candidate);
      } else {
        this._addIceCandidateToQueue(targetMid, candidate);
      }
    } else {
      // Added ice candidate to queue because it may be received before sending the offer
      this._log(this.LOG_LEVEL.DEBUG, {
        target: targetMid,
        interface: &#x27;RTCIceCandidate&#x27;,
        keys: message.type,
        log: &#x27;Not adding candidate as peer connection not present&#x27;
      });
      // NOTE ALEX: if the offer was slow, this can happen
      // we might keep a buffer of candidates to replay after receiving an offer.
      this._addIceCandidateToQueue(targetMid, candidate);
    }
  };

  /**
   * Signaling server sends an answer message.
   * - SIG_TYPE: ANSWER
   * - This occurs when a peer sends an answer message is received.
   * @method _answerHandler
   * @param {String} message.type Message type
   * @param {JSON} message The message object received.
   * @param {String} message.rid RoomId of the connected room.
   * @param {String} message.sdp Answer sessionDescription
   * @param {String} message.mid PeerId of the peer that is sending the enter shake.
   * @param {String} message.type The type of message received.
   * @trigger handshakeProgress
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._answerHandler = function(message) {
    var self = this;
    var targetMid = message.mid;
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      keys: message.type,
      log: &#x27;Received answer from peer. Session description: &#x27;
    }, message.sdp);
    self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ANSWER, targetMid);
    var answer = new window.RTCSessionDescription(message);
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      interface: &#x27;RTCSessionDescription&#x27;,
      keys: message.type,
      log: &#x27;Session description object created&#x27;
    }, answer);
    var pc = self._peerConnections[targetMid];
    // if firefox and peer is mcu, replace the sdp to suit mcu needs
    if (window.webrtcDetectedType === &#x27;moz&#x27; &amp;&amp; targetMid === &#x27;MCU&#x27;) {
      message.sdp = message.sdp.replace(/ generation 0/g, &#x27;&#x27;);
      message.sdp = message.sdp.replace(/ udp /g, &#x27; UDP &#x27;);
    }
    pc.setRemoteDescription(new window.RTCSessionDescription(answer), function() {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Remote description set&#x27;
      });
      pc.setAnswer = &#x27;remote&#x27;;
      self._addIceCandidateFromQueue(targetMid);
    }, function(error) {
      self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        keys: message.type,
        log: &#x27;Failed setting remote description: &#x27;
      }, error);
    });
  };

  /************************* Connection Action Methods ****************************/
  /**
   * We have a peer, this creates a peerconnection object to handle the call.
   * if we are the initiator, we then starts the O/A handshake.
   * @method _addPeer
   * @param {String} targetMid PeerId of the peer we should connect to.
   * @param {JSON} peerBrowser The peer browser information.
   * @param {String} peerBrowser.agent The peer browser agent.
   * @param {Integer} peerBrowser.version The peer browser version.
   * @param {Boolean} toOffer Whether we should start the O/A or wait.
   * @param {Boolean} restartConn Whether connection is restarted.
   * @param {Boolean} receiveOnly Should they only receive?
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._addPeer = function(targetMid, peerBrowser, toOffer, restartConn, receiveOnly) {
    var self = this;
    if (self._peerConnections[targetMid] &amp;&amp; !restartConn) {
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        log: &#x27;Connection to peer has already been made&#x27;
      });
      return;
    }
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      log: &#x27;Starting the connection to peer. Options provided: &#x27;
    }, {
      peerBrowser: peerBrowser,
      toOffer: toOffer,
      receiveOnly: receiveOnly,
      enableDataChannel: self._enableDataChannel
    });
    if (!restartConn) {
      self._peerConnections[targetMid] = self._createPeerConnection(targetMid);
    }
    if (!receiveOnly) {
      self._addLocalMediaStreams(targetMid);
    }
    // I&#x27;m the callee I need to make an offer
    if (toOffer) {
      if (self._enableDataChannel) {
        self._createDataChannel(targetMid);
      }
      self._doOffer(targetMid, peerBrowser);
    }
  };

  /**
   * Actually clean the peerconnection and trigger an event.
   * Can be called by _byHandler and leaveRoom.
   * @method _removePeer
   * @param {String} peerId PeerId of the peer that has left.
   * @trigger peerLeft
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._removePeer = function(peerId) {
    if (peerId !== &#x27;MCU&#x27;) {
      this._trigger(&#x27;peerLeft&#x27;, peerId, this._peerInformations[peerId], false);
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: peerId,
        log: &#x27;MCU has stopped listening and left&#x27;
      });
    }
    if (this._peerConnections[peerId]) {
      this._peerConnections[peerId].close();
      delete this._peerConnections[peerId];
    }
    if (this._peerHSPriorities[peerId]) {
      delete this._peerHSPriorities[peerId];
    }
    if (this._peerInformations[peerId]) {
      delete this._peerInformations[peerId];
    }
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      log: &#x27;Successfully removed peer&#x27;
    });
  };

  /**
   * It then sends it to the peer. Handshake step 3 (offer) or 4 (answer)
   * @method _doOffer
   * @param {String} targetMid PeerId of the peer to send offer to.
   * @param {JSON} peerBrowser The peer browser information.
   * @param {String} peerBrowser.agent The peer browser agent.
   * @param {Integer} peerBrowser.version The peer browser version.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._doOffer = function(targetMid, peerBrowser) {
    var self = this;
    var pc = self._peerConnections[targetMid];
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      log: &#x27;Checking caller status&#x27;
    }, peerBrowser);
    // NOTE ALEX: handle the pc = 0 case, just to be sure
    var inputConstraints = self._room.connection.offerConstraints;
    var sc = self._room.connection.sdpConstraints;
    for (var name in sc.mandatory) {
      if (sc.mandatory.hasOwnProperty(name)) {
        inputConstraints.mandatory[name] = sc.mandatory[name];
      }
    }
    inputConstraints.optional.concat(sc.optional);
    checkMediaDataChannelSettings(peerBrowser.agent, peerBrowser.version,
      function(beOfferer, unifiedOfferConstraints) {
      // attempt to force make firefox not to offer datachannel.
      // we will not be using datachannel in MCU
      if (window.webrtcDetectedType === &#x27;moz&#x27; &amp;&amp; peerBrowser.agent === &#x27;MCU&#x27;) {
        unifiedOfferConstraints.mandatory = unifiedOfferConstraints.mandatory || {};
        unifiedOfferConstraints.mandatory.MozDontOfferDataChannel = true;
        beOfferer = true;
      }
      if (beOfferer) {
        self._log(self.LOG_LEVEL.DEBUG, {
          target: targetMid,
          log: &#x27;Creating offer with config: &#x27;
        }, unifiedOfferConstraints);
        pc.createOffer(function(offer) {
          self._log(self.LOG_LEVEL.DEBUG, {
            target: targetMid,
            log: &#x27;Created offer&#x27;
          }, offer);
          self._setLocalAndSendMessage(targetMid, offer);
        }, function(error) {
          self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR,
            targetMid, error);
          self._log(self.LOG_LEVEL.ERROR, {
            target: targetMid,
            log: &#x27;Failed creating an offer: &#x27;
          }, error);
        }, unifiedOfferConstraints);
      } else {
        self._log(self.LOG_LEVEL.DEBUG, {
          target: targetMid,
          log: &#x27;User\&#x27;s browser is not eligible to create the offer to the other &#x27; +
            &#x27;peer. Requesting other peer to create the offer instead&#x27;
        }, peerBrowser);
        self._sendChannelMessage({
          type: self._SIG_MESSAGE_TYPE.WELCOME,
          mid: self._user.sid,
          rid: self._room.id,
          agent: window.webrtcDetectedBrowser,
          version: window.webrtcDetectedVersion,
          userInfo: self._user.info,
          target: targetMid,
          weight: -1
        });
      }
    }, inputConstraints);
  };

  /**
   * We have succesfully received an offer and set it locally. This function will take care
   * of cerating and sendng the corresponding answer. Handshake step 4.
   * @method _doAnswer
   * @param {String} targetMid PeerId of the peer to send answer to.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._doAnswer = function(targetMid) {
    var self = this;
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      log: &#x27;Creating answer with config: &#x27;
    }, self._room.connection.sdpConstraints);
    var pc = self._peerConnections[targetMid];
    if (pc) {
      pc.createAnswer(function(answer) {
        self._log(self.LOG_LEVEL.DEBUG, {
          target: targetMid,
          log: &#x27;Created answer&#x27;
        }, answer);
        self._setLocalAndSendMessage(targetMid, answer);
      }, function(error) {
        self._log(self.LOG_LEVEL.ERROR, {
          target: targetMid,
          log: &#x27;Failed creating an answer: &#x27;
        }, error);
        self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
      }, self._room.connection.sdpConstraints);
    } else {
      /* Houston ..*/
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        log: &#x27;Requested to create an answer but user does not have any existing connection to peer&#x27;
      });
      return;
    }
  };

  /**
   * Adds ice candidate to queue.
   * @method _addIceCandidateToQueue
   * @param {String} targetMid The peerId of the target peer.
   * @param {Object} candidate The ice candidate object.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._addIceCandidateToQueue = function(targetMid, candidate) {
    this._log(this.LOG_LEVEL.DEBUG, {
      target: targetMid,
      log: &#x27;Queued candidate to add after setRemoteDescription&#x27;
    }, candidate);
    this._peerCandidatesQueue[targetMid] =
      this._peerCandidatesQueue[targetMid] || [];
    this._peerCandidatesQueue[targetMid].push(candidate);
  };

  /**
   * Adds all ice candidate from the queue.
   * @method _addIceCandidateFromQueue
   * @param {String} targetMid The peerId of the target peer.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._addIceCandidateFromQueue = function(targetMid) {
    this._peerCandidatesQueue[targetMid] =
      this._peerCandidatesQueue[targetMid] || [];
    if(this._peerCandidatesQueue[targetMid].length &gt; 0) {
      for (var i = 0; i &lt; this._peerCandidatesQueue[targetMid].length; i++) {
        var candidate = this._peerCandidatesQueue[targetMid][i];
        this._log(this.LOG_LEVEL.DEBUG, {
          target: targetMid,
          log: &#x27;Added queued candidate&#x27;
        }, candidate);
        this._peerConnections[targetMid].addIceCandidate(candidate);
      }
      delete this._peerCandidatesQueue[targetMid];
    } else {
      this._log(this.LOG_LEVEL.TRACE, {
        target: targetMid,
        log: &#x27;No queued candiate to add&#x27;
      });
    }
  };

  /**
   * This takes an offer or an aswer generated locally and set it in the peerconnection
   * it then sends it to the peer. Handshake step 3 (offer) or 4 (answer)
   * @method _setLocalAndSendMessage
   * @param {String} targetMid PeerId of the peer to send offer/answer to.
   * @param {JSON} sessionDescription This should be provided by the peerconnection API.
   *   User might &#x27;tamper&#x27; with it, but then , the setLocal may fail.
   * @trigger handshakeProgress
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._setLocalAndSendMessage = function(targetMid, sessionDescription) {
    var self = this;
    var pc = self._peerConnections[targetMid];
    if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER &amp;&amp; pc.setAnswer) {
      self._log(self.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: sessionDescription.type,
        log: &#x27;Ignoring session description. User has already set local answer&#x27;
      });
      return;
    }
    if (sessionDescription.type === self.HANDSHAKE_PROGRESS.OFFER &amp;&amp; pc.setOffer) {
      self._log(self.LOG_LEVEL.TRACE, {
        target: targetMid,
        keys: sessionDescription.type,
        log: &#x27;Ignoring session description. User has already set local offer&#x27;
      });
      return;
    }
    // NOTE ALEX: handle the pc = 0 case, just to be sure
    var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
    // remove h264 invalid pref
    sdpLines = self._removeFirefoxH264Pref(sdpLines);
    // add stereo option
    if (self._streamSettings.stereo) {
      self._addStereo(sdpLines);
    }
    self._log(self.LOG_LEVEL.INFO, {
      target: targetMid,
      log: &#x27;Requested stereo: &#x27;
    }, self._streamSettings.stereo || false);
    // set sdp bitrate
    if (self._streamSettings.bandwidth) {
      sdpLines = self._setSDPBitrate(sdpLines, self._streamSettings.bandwidth);
    }
    self._streamSettings.bandwidth = self._streamSettings.bandwidth || {};
    self._log(self.LOG_LEVEL.INFO, {
      target: targetMid,
      log: &#x27;Custom bandwidth settings: &#x27;
    }, {
      audio: (self._streamSettings.bandwidth.audio || &#x27;Not set&#x27;) + &#x27; kB/s&#x27;,
      video: (self._streamSettings.bandwidth.video || &#x27;Not set&#x27;) + &#x27; kB/s&#x27;,
      data: (self._streamSettings.bandwidth.data || &#x27;Not set&#x27;) + &#x27; kB/s&#x27;
    });
    sessionDescription.sdp = sdpLines.join(&#x27;\r\n&#x27;);
    // NOTE ALEX: opus should not be used for mobile
    // Set Opus as the preferred codec in SDP if Opus is present.
    //sessionDescription.sdp = preferOpus(sessionDescription.sdp);
    // limit bandwidth
    //sessionDescription.sdp = this._limitBandwidth(sessionDescription.sdp);
    self._log(self.LOG_LEVEL.TRACE, {
      target: targetMid,
      interface: &#x27;RTCSessionDescription&#x27;,
      keys: sessionDescription.type,
      log: &#x27;Updated session description: &#x27;
    }, sessionDescription);
    pc.setLocalDescription(sessionDescription, function() {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        keys: sessionDescription.type,
        log: &#x27;Local description set&#x27;
      });
      self._trigger(&#x27;handshakeProgress&#x27;, sessionDescription.type, targetMid);
      if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER) {
        pc.setAnswer = &#x27;local&#x27;;
      } else {
        pc.setOffer = &#x27;local&#x27;;
      }
      if (self._enableIceTrickle || (!self._enableIceTrickle &amp;&amp;
        sessionDescription.type !== self.HANDSHAKE_PROGRESS.OFFER)) {
        self._sendChannelMessage({
          type: sessionDescription.type,
          sdp: sessionDescription.sdp,
          mid: self._user.sid,
          target: targetMid,
          rid: self._room.id
        });
      } else {
        self._log(self.LOG_LEVEL.TRACE, {
          target: targetMid,
          keys: sessionDescription.type,
          log: &#x27;Waiting for Ice gathering to complete to prevent Ice trickle&#x27;
        });
      }
    }, function(error) {
      self._trigger(&#x27;handshakeProgress&#x27;, self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        keys: sessionDescription.type,
        log: &#x27;Failed setting local description: &#x27;
      }, error);
    });
  };

  /************************* Constraints/SDP Modification Methods ****************************/
  /**
   * Sets the STUN server specially for Firefox for ICE Connection.
   * @method _setFirefoxIceServers
   * @param {JSON} config Ice configuration servers url object.
   * @return {JSON} Updated configuration
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._setFirefoxIceServers = function(config) {
    if (window.webrtcDetectedType === &#x27;moz&#x27;) {
      this._log(this.LOG_LEVEL.TRACE, &#x27;Updating firefox Ice server configuration&#x27;, config);
      // NOTE ALEX: shoul dbe given by the server
      var newIceServers = [{
        &#x27;url&#x27;: &#x27;stun:stun.services.mozilla.com&#x27;
      }];
      for (var i = 0; i &lt; config.iceServers.length; i++) {
        var iceServer = config.iceServers[i];
        var iceServerType = iceServer.url.split(&#x27;:&#x27;)[0];
        if (iceServerType === &#x27;stun&#x27;) {
          if (iceServer.url.indexOf(&#x27;google&#x27;)) {
            continue;
          }
          iceServer.url = [iceServer.url];
          newIceServers.push(iceServer);
        } else {
          var newIceServer = {};
          newIceServer.credential = iceServer.credential;
          newIceServer.url = iceServer.url.split(&#x27;:&#x27;)[0];
          newIceServer.username = iceServer.url.split(&#x27;:&#x27;)[1].split(&#x27;@&#x27;)[0];
          newIceServer.url += &#x27;:&#x27; + iceServer.url.split(&#x27;:&#x27;)[1].split(&#x27;@&#x27;)[1];
          newIceServers.push(newIceServer);
        }
      }
      config.iceServers = newIceServers;
      this._log(this.LOG_LEVEL.DEBUG, &#x27;Updated firefox Ice server configuration: &#x27;, config);
    }
    return config;
  };

  /**
   * Finds a line in the SDP and returns it.
   * - To set the value to the line, add an additional parameter to the method.
   * @method _findSDPLine
   * @param {Array} sdpLines Sdp received.
   * @param {Array} condition The conditions.
   * @param {String} value Value to set Sdplines to
   * @return {Array} [index, line] - Returns the sdpLines based on the condition
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._findSDPLine = function(sdpLines, condition, value) {
    for (var index in sdpLines) {
      if (sdpLines.hasOwnProperty(index)) {
        for (var c in condition) {
          if (condition.hasOwnProperty(c)) {
            if (sdpLines[index].indexOf(c) === 0) {
              sdpLines[index] = value;
              return [index, sdpLines[index]];
            }
          }
        }
      }
    }
    return [];
  };

  /**
   * Adds stereo feature to the SDP.
   * - This requires OPUS to be enabled in the SDP or it will not work.
   * @method _addStereo
   * @param {Array} sdpLines Sdp received.
   * @return {Array} Updated version with Stereo feature
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._addStereo = function(sdpLines) {
    var opusLineFound = false,
      opusPayload = 0;
    // Check if opus exists
    var rtpmapLine = this._findSDPLine(sdpLines, [&#x27;a=rtpmap:&#x27;]);
    if (rtpmapLine.length) {
      if (rtpmapLine[1].split(&#x27; &#x27;)[1].indexOf(&#x27;opus/48000/&#x27;) === 0) {
        opusLineFound = true;
        opusPayload = (rtpmapLine[1].split(&#x27; &#x27;)[0]).split(&#x27;:&#x27;)[1];
      }
    }
    // Find the A=FMTP line with the same payload
    if (opusLineFound) {
      var fmtpLine = this._findSDPLine(sdpLines, [&#x27;a=fmtp:&#x27; + opusPayload]);
      if (fmtpLine.length) {
        sdpLines[fmtpLine[0]] = fmtpLine[1] + &#x27;; stereo=1&#x27;;
      }
    }
    return sdpLines;
  };

  /**
   * Set Audio, Video and Data Bitrate in SDP
   * @method _setSDPBitrate
   * @param {Array} sdpLines Sdp received.
   * @return {Array} Updated version with custom Bandwidth settings
   * @private
   * @since 0.2.0
   */
  Skyway.prototype._setSDPBitrate = function(sdpLines) {
    // Find if user has audioStream
    var bandwidth = this._streamSettings.bandwidth;
    var maLineFound = this._findSDPLine(sdpLines, [&#x27;m=&#x27;, &#x27;a=&#x27;]).length;
    var cLineFound = this._findSDPLine(sdpLines, [&#x27;c=&#x27;]).length;
    // Find the RTPMAP with Audio Codec
    if (maLineFound &amp;&amp; cLineFound) {
      if (bandwidth.audio) {
        var audioLine = this._findSDPLine(sdpLines, [&#x27;a=mid:audio&#x27;, &#x27;m=mid:audio&#x27;]);
        sdpLines.splice(audioLine[0], 0, &#x27;b=AS:&#x27; + bandwidth.audio);
      }
      if (bandwidth.video) {
        var videoLine = this._findSDPLine(sdpLines, [&#x27;a=mid:video&#x27;, &#x27;m=mid:video&#x27;]);
        sdpLines.splice(videoLine[0], 0, &#x27;b=AS:&#x27; + bandwidth.video);
      }
      if (bandwidth.data) {
        var dataLine = this._findSDPLine(sdpLines, [&#x27;a=mid:data&#x27;, &#x27;m=mid:data&#x27;]);
        sdpLines.splice(dataLine[0], 0, &#x27;b=AS:&#x27; + bandwidth.data);
      }
    }
    return sdpLines;
  };

  /**
   * Removes Firefox 32 H264 preference in sdp.
   * - As noted in bugzilla as bug in [here](https://bugzilla.mozilla.org/show_bug.cgi?id=1064247).
   * @method _removeFirefoxH264Pref
   * @param {Array} sdpLines Sdp received.
   * @return {Array} Updated version removing Firefox h264 pref support.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._removeFirefoxH264Pref = function(sdpLines) {
    var invalidLineIndex = sdpLines.indexOf(
      &#x27;a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1&#x27;);
    if (invalidLineIndex &gt; -1) {
      this._log(this.LOG_LEVEL.DEBUG, &#x27;Firefox H264 invalid pref found: &#x27;, invalidLineIndex);
      sdpLines.splice(invalidLineIndex, 1);
    }
    return sdpLines;
  };

  /************************* MediaStream Methods ****************************/
  /**
   * Parse stream settings
   * @method _parseStreamSettings
   * @param {JSON} options Optional. Media Constraints.
   * @param {JSON} options.userData Optional. User custom data.
   * @param {Boolean|JSON} options.audio This call requires audio
   * @param {Boolean} options.audio.stereo Enabled stereo or not
   * @param {Boolean|JSON} options.video This call requires video
   * @param {JSON} options.video.resolution [Rel: Skyway.VIDEO_RESOLUTION]
   * @param {Integer} options.video.resolution.width Video width
   * @param {Integer} options.video.resolution.height Video height
   * @param {Integer} options.video.frameRate Mininum frameRate of Video
   * @param {String} options.bandwidth Bandwidth settings
   * @param {String} options.bandwidth.audio Audio Bandwidth
   * @param {String} options.bandwidth.video Video Bandwidth
   * @param {String} options.bandwidth.data Data Bandwidth
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._parseStreamSettings = function(options) {
    options = options || {};
    this._log(this.LOG_LEVEL.DEBUG, &#x27;Parsing stream settings. Stream options: &#x27;, options);
    this._user.info = this._user.info || {};
    this._user.info.settings = this._user.info.settings || {};
    this._user.info.mediaStatus = this._user.info.mediaStatus || {};
    // Set User
    this._user.info.userData = options.userData || this._user.info.userData || &#x27;&#x27;;
    // Set Bandwidth
    this._streamSettings.bandwidth = options.bandwidth ||
      this._streamSettings.bandwidth || {};
    this._user.info.settings.bandwidth = options.bandwidth ||
      this._user.info.settings.bandwidth || {};
    // Set audio settings
    this._user.info.settings.audio = (typeof options.audio === &#x27;boolean&#x27; ||
      typeof options.audio === &#x27;object&#x27;) ? options.audio :
      (this._streamSettings.audio || false);
    this._user.info.mediaStatus.audioMuted = (options.audio) ?
      ((typeof this._user.info.mediaStatus.audioMuted === &#x27;boolean&#x27;) ?
      this._user.info.mediaStatus.audioMuted : !options.audio) : true;
    // Set video settings
    this._user.info.settings.video = (typeof options.video === &#x27;boolean&#x27; ||
      typeof options.video === &#x27;object&#x27;) ? options.video :
      (this._streamSettings.video || false);
    // Set user media status options
    this._user.info.mediaStatus.videoMuted = (options.video) ?
      ((typeof this._user.info.mediaStatus.videoMuted === &#x27;boolean&#x27;) ?
      this._user.info.mediaStatus.videoMuted : !options.video) : true;

    if (!options.video &amp;&amp; !options.audio) {
      return;
    }
    // If undefined, at least set to boolean
    options.video = options.video || false;
    options.audio = options.audio || false;

    // Set Video
    if (typeof options.video === &#x27;object&#x27;) {
      if (typeof options.video.resolution === &#x27;object&#x27;) {
        var width = options.video.resolution.width;
        var height = options.video.resolution.height;
        var frameRate = (typeof options.video.frameRate === &#x27;number&#x27;) ?
          options.video.frameRate : 50;
        if (!width || !height) {
          options.video = true;
        } else {
          options.video = {
            mandatory: {
              minWidth: width,
              minHeight: height
            },
            optional: [{ minFrameRate: frameRate }]
          };
        }
      }
    }
    // Set Audio
    if (typeof options.audio === &#x27;object&#x27;) {
      options.stereo = (typeof options.audio.stereo === &#x27;boolean&#x27;) ?
        options.audio.stereo : false;
      options.audio = true;
    }
    // Set stream settings
    // use default video media size if no width or height provided
    this._streamSettings.video = (typeof options.video === &#x27;boolean&#x27; &amp;&amp; options.video) ?
      this._room.connection.mediaConstraints : options.video;
    this._streamSettings.audio = options.audio;
    this._streamSettings.stereo = options.stereo;

    this._log(this.LOG_LEVEL.DEBUG, &#x27;Parsed user stream settings&#x27;, this._user.info);
    this._log(this.LOG_LEVEL.INFO, &#x27;User media status: &#x27;, {
      audio: options.audioMuted,
      video: options.videoMuted
    });
  };

  /**
   * Opens or closes existing MediaStreams.
   * @method _setLocalMediaStreams
   * @param {JSON} options
   * @param {JSON} options.audio Enable audio or not
   * @param {JSON} options.video Enable video or not
   * @return {Boolean} Whether we should re-fetch mediaStreams or not
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._setLocalMediaStreams = function(options) {
    var hasAudioTracks = false, hasVideoTracks = false;
    if (!this._user) {
      this._log(this.LOG_LEVEL.ERROR, &#x27;User have no active streams&#x27;);
      return;
    }
    for (var stream in this._user.streams) {
      if (this._user.streams.hasOwnProperty(stream)) {
        var audios = this._user.streams[stream].getAudioTracks();
        var videos = this._user.streams[stream].getVideoTracks();
        for (var audio in audios) {
          if (audios.hasOwnProperty(audio)) {
            audios[audio].enabled = options.audio;
            hasAudioTracks = true;
          }
        }
        for (var video in videos) {
          if (videos.hasOwnProperty(video)) {
            videos[video].enabled = options.video;
            hasVideoTracks = true;
          }
        }
        if (!options.video &amp;&amp; !options.audio) {
          this._user.streams[stream].active = false;
        } else {
          this._user.streams[stream].active = true;
        }
      }
    }
    return ((!hasAudioTracks &amp;&amp; options.audio) ||
      (!hasVideoTracks &amp;&amp; options.video));
  };

  /**
   * Sends our Local MediaStreams to other Peers.
   * By default, it sends all it&#x27;s other stream
   * @method _addLocalMediaStreams
   * @param {String} peerId PeerId of the peer to send local stream to.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._addLocalMediaStreams = function(peerId) {
    // NOTE ALEX: here we could do something smarter
    // a mediastream is mainly a container, most of the info
    // are attached to the tracks. We should iterates over track and print
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      log: &#x27;Adding local stream&#x27;
    });
    if (Object.keys(this._user.streams).length &gt; 0) {
      for (var stream in this._user.streams) {
        if (this._user.streams.hasOwnProperty(stream)) {
          if (this._user.streams[stream].active) {
            this._peerConnections[peerId].addStream(this._user.streams[stream]);
            this._log(this.LOG_LEVEL.DEBUG, {
              target: peerId,
              interface: &#x27;MediaStream&#x27;,
              keys: stream,
              log: &#x27;Sending stream&#x27;
            });
          }
        }
      }
    } else {
      this._log(this.LOG_LEVEL.WARN, {
        target: peerId,
        log: &#x27;No media to send. Will be only receiving&#x27;
      });
    }
  };

  /**
   * Handles all audio and video mute events.
   * - If there is no available audio or video stream, it will call
   *   {{#crossLink &quot;Skyway/leaveRoom:method&quot;}}leaveRoom(){{/crossLink}}
   *   and call {{#crossLink &quot;Skyway/joinRoom:method&quot;}}joinRoom(){{/crossLink}}
   *   to join user in the room to send their audio and video stream.
   * @method _handleLocalMediaStreams
   * @param {String} mediaType Media types expected to receive.
   *   [Rel: &#x27;audio&#x27; or &#x27;video&#x27;]
   * @param {Boolean} enableMedia Enable it or disable it
   * @trigger peerUpdated
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._handleLocalMediaStreams = function(mediaType, enableMedia) {
    if (mediaType !== &#x27;audio&#x27; &amp;&amp; mediaType !== &#x27;video&#x27;) {
      return;
    } else if (!this._inRoom) {
      this._log(this.LOG_LEVEL.ERROR, &#x27;Failed &#x27; +
        ((enableMedia) ? &#x27;enabling&#x27; : &#x27;disabling&#x27;) +
        &#x27; &#x27; + mediaType + &#x27;. User is not in the room&#x27;);
      return;
    }
    // Loop and enable tracks accordingly
    var hasTracks = false, isStreamActive = false;
    for (var stream in this._user.streams) {
      if (this._user.streams.hasOwnProperty(stream)) {
        var tracks = (mediaType === &#x27;audio&#x27;) ?
          this._user.streams[stream].getAudioTracks() :
          this._user.streams[stream].getVideoTracks();
        for (var track in tracks) {
          if (tracks.hasOwnProperty(track)) {
            tracks[track].enabled = enableMedia;
            hasTracks = true;
          }
        }
        isStreamActive = this._user.streams[stream].active;
      }
    }
    this._log(this.LOG_LEVEL.TRACE, &#x27;Update to is&#x27; + mediaType + &#x27;Muted status -&gt; &#x27;, enableMedia);
    // Broadcast to other peers
    if (!(hasTracks &amp;&amp; isStreamActive) &amp;&amp; enableMedia) {
      this.leaveRoom();
      var hasProperty = (this._user) ? ((this._user.info) ? (
        (this._user.info.settings) ? true : false) : false) : false;
      // set timeout? to 500?
      this.joinRoom({
        audio: (mediaType === &#x27;audio&#x27;) ? true : ((hasProperty) ?
          this._user.info.settings.audio : false),
        video: (mediaType === &#x27;video&#x27;) ? true : ((hasProperty) ?
          this._user.info.settings.video : false)
      });
      this._user.info.mediaStatus[mediaType + &#x27;Muted&#x27;] = !enableMedia;
    } else {
      this._sendChannelMessage({
        type: ((mediaType === &#x27;audio&#x27;) ? this._SIG_MESSAGE_TYPE.MUTE_AUDIO :
          this._SIG_MESSAGE_TYPE.MUTE_VIDEO),
        mid: this._user.sid,
        rid: this._room.id,
        muted: !enableMedia
      });
      this._user.info.mediaStatus[mediaType + &#x27;Muted&#x27;] = !enableMedia;
      this._trigger(&#x27;peerUpdated&#x27;, this._user.sid, this._user.info, true);
    }
  };

  /**
   * Waits for MediaStream.
   * - Once the stream is loaded, callback is called
   * - If there&#x27;s not a need for stream, callback is called
   * @method _waitForLocalMediaStream
   * @param {Function} callback Callback after requested constraints are loaded.
   * @param {JSON} options Optional. Media Constraints.
   * @param {JSON} options.userData Optional. User custom data.
   * @param {Boolean|JSON} options.audio This call requires audio
   * @param {Boolean} options.audio.stereo Enabled stereo or not
   * @param {Boolean|JSON} options.video This call requires video
   * @param {JSON} options.video.resolution [Rel: Skyway.VIDEO_RESOLUTION]
   * @param {Integer} options.video.resolution.width Video width
   * @param {Integer} options.video.resolution.height Video height
   * @param {Integer} options.video.frameRate Mininum frameRate of Video
   * @param {String} options.bandwidth Bandwidth settings
   * @param {String} options.bandwidth.audio Audio Bandwidth
   * @param {String} options.bandwidth.video Video Bandwidth
   * @param {String} options.bandwidth.data Data Bandwidth
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._waitForLocalMediaStream = function(callback, options) {
    var self = this;
    options = options || {};
    self.getUserMedia(options);

    self._log(self.LOG_LEVEL.TRACE, &#x27;Requested audio: &#x27;,
      ((typeof options.audio === &#x27;boolean&#x27;) ? options.audio : false));
    self._log(self.LOG_LEVEL.TRACE, &#x27;Requested video: &#x27;,
      ((typeof options.video === &#x27;boolean&#x27;) ? options.video : false));

    // If options video or audio false, do the opposite to throw a true.
    var hasAudio = (options.audio) ? false : true;
    var hasVideo = (options.video) ? false : true;

    if (options.video || options.audio) {
      // lets wait for a minute and then we pull the updates
      var count = 0;
      var checkForStream = setInterval(function() {
        if (count &lt; 5) {
          for (var stream in self._user.streams) {
            if (self._user.streams.hasOwnProperty(stream)) {
              if (options.audio &amp;&amp;
                self._user.streams[stream].getAudioTracks().length &gt; 0) {
                hasAudio = true;
              }
              if (options.video &amp;&amp;
                self._user.streams[stream].getVideoTracks().length &gt; 0) {
                hasVideo = true;
              }
              if (hasAudio &amp;&amp; hasVideo) {
                clearInterval(checkForStream);
                callback();
              } else {
                count++;
              }
            }
          }
        } else {
          clearInterval(checkForStream);
          var error = ((!hasAudio &amp;&amp; options.audio) ?  &#x27;Expected audio but no &#x27; +
            &#x27;audio stream received&#x27; : &#x27;&#x27;) +  &#x27;\n&#x27; + ((!hasVideo &amp;&amp; options.video) ?
            &#x27;Expected video but no video stream received&#x27; : &#x27;&#x27;);
          self._log(self.LOG_LEVEL.ERROR, {
            interface: &#x27;Socket&#x27;,
            keys: self._selectedRoom,
            log: &#x27;Failed joining room: &#x27;
          }, error);
          self._trigger(&#x27;mediaAccessError&#x27;, error);
        }
      }, 2000);
    } else {
      callback();
    }
  };

  /************************* Create Methods ****************************/
  /**
   * Creates a peerconnection to communicate with the peer whose ID is &#x27;targetMid&#x27;.
   * All the peerconnection callbacks are set up here. This is a quite central piece.
   * @method _createPeerConnection
   * @param {String} targetMid
   * @return {Object} The created peer connection object.
   * @private
   * @since 0.5.1
   */
  Skyway.prototype._createPeerConnection = function(targetMid) {
    var pc, self = this;
    try {
      pc = new window.RTCPeerConnection(
        self._room.connection.peerConfig,
        self._room.connection.peerConstraints);
      self._log(self.LOG_LEVEL.INFO, {
        target: targetMid,
        log: &#x27;Created peer connection&#x27;
      });
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        log: &#x27;Peer connection config: &#x27;
      }, self._room.connection.peerConfig);
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        log: &#x27;Peer connection constraints: &#x27;
      }, self._room.connection.peerConstraints);
    } catch (error) {
      self._log(self.LOG_LEVEL.ERROR, {
        target: targetMid,
        log: &#x27;Failed creating peer connection: &#x27;
      }, error);
      return null;
    }
    // attributes (added on by Temasys)
    pc.setOffer = &#x27;&#x27;;
    pc.setAnswer = &#x27;&#x27;;
    // callbacks
    // standard not implemented: onnegotiationneeded,
    pc.ondatachannel = function(event) {
      var dc = event.channel || event;
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: dc.label,
        log: &#x27;Received datachannel -&gt; &#x27;
      }, dc);
      if (self._enableDataChannel) {
        self._createDataChannel(targetMid, dc);
      } else {
        self._log(self.LOG_LEVEL.WARN, {
          target: targetMid,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: dc.label,
          log: &#x27;Not adding datachannel&#x27;
        });
      }
    };
    pc.onaddstream = function(event) {
      self._onRemoteStreamAdded(targetMid, event);
    };
    pc.onicecandidate = function(event) {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        interface: &#x27;RTCIceCandidate&#x27;,
        log: &#x27;Ice candidate generated -&gt; &#x27;
      }, event.candidate);
      self._onIceCandidate(targetMid, event);
    };
    pc.oniceconnectionstatechange = function(evt) {
      checkIceConnectionState(targetMid, pc.iceConnectionState,
        function(iceConnectionState) {
        self._log(self.LOG_LEVEL.DEBUG, {
          target: targetMid,
          interface: &#x27;RTCIceConnectionState&#x27;,
          log: &#x27;Ice connection state changed -&gt; &#x27;
        }, iceConnectionState);
        self._trigger(&#x27;iceConnectionState&#x27;, iceConnectionState, targetMid);
        /**** SJS-53: Revert of commit ******
        // resend if failed
        if (iceConnectionState === self.ICE_CONNECTION_STATE.FAILED) {
          self._log(self.LOG_LEVEL.DEBUG, {
            target: targetMid,
            interface: &#x27;RTCIceConnectionState&#x27;,
            log: &#x27;Ice connection state failed. Re-negotiating connection&#x27;
          });
          self._removePeer(targetMid);
          self._sendChannelMessage({
            type: self._SIG_MESSAGE_TYPE.WELCOME,
            mid: self._user.sid,
            rid: self._room.id,
            agent: window.webrtcDetectedBrowser,
            version: window.webrtcDetectedVersion,
            userInfo: self._user.info,
            target: targetMid,
            restartNego: true,
            hsPriority: -1
          });
        } *****/
      });
    };
    // pc.onremovestream = function () {
    //   self._onRemoteStreamRemoved(targetMid);
    // };
    pc.onsignalingstatechange = function() {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: targetMid,
        interface: &#x27;RTCSignalingState&#x27;,
        log: &#x27;Peer connection state changed -&gt; &#x27;
      }, pc.signalingState);
      self._trigger(&#x27;peerConnectionState&#x27;, pc.signalingState, targetMid);
    };
    pc.onicegatheringstatechange = function() {
      self._log(self.LOG_LEVEL.TRACE, {
        target: targetMid,
        interface: &#x27;RTCIceGatheringState&#x27;,
        log: &#x27;Ice gathering state changed -&gt; &#x27;
      }, pc.iceGatheringState);
      self._trigger(&#x27;candidateGenerationState&#x27;, pc.iceGatheringState, targetMid);
    };
    return pc;
  };

  /**
   * Create a DataChannel. Only SCTPDataChannel support
   * @method _createDataChannel
   * @param {String} peerId PeerId of the peer which the datachannel is connected to
   * @param {Object} dc The datachannel object received.
   * @trigger dataChannelState
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._createDataChannel = function(peerId, dc) {
    var self = this;
    var channelName = (dc) ? dc.label : peerId;
    var pc = self._peerConnections[peerId];
    var dcOpened = function () {
      self._log(self.LOG_LEVEL.TRACE, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;Datachannel state -&gt;&#x27;
      }, &#x27;open&#x27;);
      self._log(self.LOG_LEVEL.TRACE, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;Binary type support -&gt; &#x27;
      }, dc.binaryType);
      self._dataChannels[peerId] = dc;
      self._trigger(&#x27;dataChannelState&#x27;, dc.readyState, peerId);
    };
    if (window.webrtcDetectedDCSupport !== &#x27;SCTP&#x27; &amp;&amp;
      window.webrtcDetectedDCSupport !== &#x27;plugin&#x27;) {
      self._log(self.LOG_LEVEL.WARN, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;SCTP not supported&#x27;
      });
      return;
    }
    if (!dc) {
      dc = pc.createDataChannel(channelName);
      self._trigger(&#x27;dataChannelState&#x27;, dc.readyState, peerId);
      var checkDcOpened = setInterval(function () {
        if (dc.readyState === self.DATA_CHANNEL_STATE.OPEN) {
          clearInterval(checkDcOpened);
          dcOpened();
        }
      }, 50);
    }
    if (dc.readyState === self.DATA_CHANNEL_STATE.OPEN) {
      dcOpened();
    } else {
      dc.onopen = dcOpened;
    }
    dc.onerror = function(error) {
      self._log(self.LOG_LEVEL.ERROR, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;Exception occurred in datachannel: &#x27;
      }, error);
      self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.ERROR, peerId, error);
    };
    dc.onclose = function() {
      self._log(self.LOG_LEVEL.DEBUG, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;Datachannel state -&gt;&#x27;
      }, &#x27;closed&#x27;);
      self._closeDataChannel(peerId);
      self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.CLOSED, peerId);

      // if closes because of firefox, reopen it again
      if (self._peerConnections[peerId]) {
        self._createDataChannel(peerId);
      }
    };
    dc.onmessage = function(event) {
      self._dataChannelProtocolHandler(event.data, peerId, channelName);
    };
  };

  /************************* Socket Channel Methods ****************************/
  /**
   * Sends a message to the signaling server.
   * - Not to be confused with method
   *   {{#crossLink &quot;Skyway/sendMessage:method&quot;}}sendMessage(){{/crossLink}}
   *   that broadcasts messages. This is for sending socket messages.
   * @method _sendChannelMessage
   * @param {JSON} message
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._sendChannelMessage = function(message) {
    if (!this._channelOpen) {
      return;
    }
    var messageString = JSON.stringify(message);
    this._log(this.LOG_LEVEL.DEBUG, {
      target: (message.target ? message.target : &#x27;server&#x27;),
      log: &#x27;Sending to peer&#x27; + ((!message.target) ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27; -&gt; &#x27;
    }, message.type);
    this._socket.send(messageString);
  };

  /**
   * Initiate a socket signaling connection.
   * @method _openChannel
   * @trigger channelMessage, channelOpen, channelError, channelClose
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._openChannel = function() {
    var self = this;
    if (self._channelOpen ||
      self._readyState !== self.READY_STATE_CHANGE.COMPLETED) {
      return;
    }
    self._signalingServerPort = (window.location.protocol === &#x27;https:&#x27; ? &#x27;443&#x27; : &#x27;80&#x27;);
    var ip_signaling = window.location.protocol + &#x27;//&#x27; + self._signalingServer +
      &#x27;:&#x27; + self._signalingServerPort;

    self._log(self.LOG_LEVEL.TRACE, &#x27;Opening channel with signaling server url: &#x27;, ip_signaling);

    self._socket = io.connect(ip_signaling, {
      forceNew: true,
      transports: [&#x27;websocket&#x27;]
    });
    self._socket.on(&#x27;connect&#x27;, function() {
      self._channelOpen = true;
      self._trigger(&#x27;channelOpen&#x27;);
      self._log(self.LOG_LEVEL.TRACE, {
        interface: &#x27;Socket&#x27;,
        log: &#x27;Channel opened&#x27;
      });
    });
    self._socket.on(&#x27;error&#x27;, function(error) {
      self._channelOpen = false;
      self._trigger(&#x27;channelError&#x27;, error);
      self._log(self.LOG_LEVEL.ERROR, {
        interface: &#x27;Socket&#x27;,
        log: &#x27;Exception occurred: &#x27;
      }, error);
    });
    self._socket.on(&#x27;disconnect&#x27;, function() {
      self._trigger(&#x27;channelClose&#x27;);
      self._log(self.LOG_LEVEL.TRACE, {
        interface: &#x27;Socket&#x27;,
        log: &#x27;Channel closed&#x27;
      });
    });
    self._socket.on(&#x27;message&#x27;, function(message) {
      self._log(self.LOG_LEVEL.TRACE, {
        interface: &#x27;Socket&#x27;,
        log: &#x27;Received message&#x27;
      });
      self._processSigMessage(message);
    });
  };

  /**
   * Closes the socket signaling connection.
   * @method _closeChannel
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._closeChannel = function() {
    if (!this._channelOpen) {
      return;
    }
    this._socket.disconnect();
    this._socket = null;
    this._channelOpen = false;
  };

  /************************* Datachannel Methods ****************************/
  /**
   * Sends data to the datachannel.
   * @method _sendDataChannelMessage
   * @param {String} peerId PeerId of the peer&#x27;s datachannel to send data.
   * @param {JSON} data The data to send.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._sendDataChannelMessage = function(peerId, data) {
    var dc = this._dataChannels[peerId];
    if (!dc) {
      this._log(this.LOG_LEVEL.ERROR, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: dc.label,
        log: &#x27;Datachannel connection to peer does not exist&#x27;
      });
      return;
    } else {
      if (dc.readyState === this.DATA_CHANNEL_STATE.OPEN) {
        var dataString = (typeof data === &#x27;object&#x27;) ? JSON.stringify(data) : data;
        this._log(this.LOG_LEVEL.DEBUG, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: dc.label,
          log: &#x27;Sending to peer -&gt; &#x27;
        }, (data.type || &#x27;DATA&#x27;));
        dc.send(dataString);
      } else {
        this._log(this.LOG_LEVEL.ERROR, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: dc.label,
          log: &#x27;Datachannel is not opened&#x27;
        }, &#x27;State: &#x27; + dc.readyState);
        this._trigger(&#x27;dataChannelState&#x27;, this.DATA_CHANNEL_STATE.ERROR,
          peerId, &#x27;Datachannel is not ready.\nState is: &#x27; + dc.readyState);
      }
    }
  };

  /**
   * Closes the datachannel.
   * @method _closeDataChannel
   * @param {String} peerId PeerId of the peer&#x27;s datachannel to close.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._closeDataChannel = function(peerId) {
    var dc = this._dataChannels[peerId];
    if (dc) {
      if (dc.readyState !== this.DATA_CHANNEL_STATE.CLOSED) {
        dc.close();
      }
      delete this._dataChannels[peerId];
      this._log(this.LOG_LEVEL.TRACE, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: dc.label,
        log: &#x27;Sucessfully removed datachannel&#x27;
      });
    }
  };

  /**
   * Sets the datachannel timeout.
   * - If timeout is met, it will send the &#x27;ERROR&#x27; message
   * @method _setDataChannelTimeout
   * @param {String} peerId PeerId of the datachannel to set timeout.
   * @param {Integer} timeout The timeout to set in seconds.
   * @param {Boolean} isSender Is peer the sender or the receiver?
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._setDataChannelTimeout = function(peerId, timeout, isSender) {
    var self = this;
    if (!self._dataTransfersTimeout[peerId]) {
      self._dataTransfersTimeout[peerId] = [];
    }
    var type = (isSender) ? self.DATA_TRANSFER_TYPE.UPLOAD :
      self.DATA_TRANSFER_TYPE.DOWNLOAD;
    self._dataTransfersTimeout[peerId][type] = setTimeout(function() {
      var name;
      if (self._dataTransfersTimeout[peerId][type]) {
        if (isSender) {
          name = self._uploadDataSessions[peerId].name;
          delete self._uploadDataTransfers[peerId];
          delete self._uploadDataSessions[peerId];
        } else {
          name = self._downloadDataSessions[peerId].name;
          delete self._downloadDataTransfers[peerId];
          delete self._downloadDataSessions[peerId];
        }
        self._sendDataChannelMessage(peerId, {
          type: self._DC_PROTOCOL_TYPE.ERROR,
          sender: self._user.sid,
          name: name,
          content: &#x27;Connection Timeout. Longer than &#x27; + timeout +
            &#x27; seconds. Connection is abolished.&#x27;,
          isUploadError: isSender
        });
        // TODO: Find a way to add channel name so it&#x27;s more specific
        self._log(self.LOG_LEVEL.ERROR, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: &#x27;&#x27;,
          log: &#x27;Failed transfering data: &#x27;
        }, &#x27;Transfer &#x27; + ((isSender) ? &#x27;for&#x27;: &#x27;from&#x27;) + &#x27; &#x27; + peerId +
        &#x27; failed. Connection timeout&#x27;);
        self._clearDataChannelTimeout(peerId, isSender);
      }
    }, 1000 * timeout);
  };

  /**
   * Clears the datachannel timeout.
   * @method _clearDataChannelTimeout
   * @param {String} peerId PeerId of the datachannel to clear timeout.
   * @param {Boolean} isSender Is peer the sender or the receiver?
   * @param {Skyway} self Skyway object.
   * @private
   * @since 0.5.0
   */
  Skyway.prototype._clearDataChannelTimeout = function(peerId, isSender) {
    if (this._dataTransfersTimeout[peerId]) {
      var type = (isSender) ? this.DATA_TRANSFER_TYPE.UPLOAD :
        this.DATA_TRANSFER_TYPE.DOWNLOAD;
      clearTimeout(this._dataTransfersTimeout[peerId][type]);
      delete this._dataTransfersTimeout[peerId][type];
    }
  };

  /**
   * Sends blob data to individual peer.
   * - This sends the {{#crossLink &quot;Skyway/WRQ:event&quot;}}WRQ{{/crossLink}}
   *   and to initiate the TFTP protocol.
   * @method _sendBlobDataToPeer
   * @param {Blob} data The blob data to be sent over.
   * @param {JSON} dataInfo The data information.
   * @param {String} dataInfo.transferId TransferId of the data.
   * @param {String} dataInfo.name Data name.
   * @param {Integer} dataInfo.timeout Data timeout to wait for packets.
   *   [Default is 60].
   * @param {Integer} dataInfo.size Data size
   * @param {String} targetPeerId PeerId targeted to receive data.
   *   Leave blank to send to all peers.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._sendBlobDataToPeer = function(data, dataInfo, targetPeerId) {
    var binarySize = parseInt((dataInfo.size * (4 / 3)).toFixed(), 10);
    var chunkSize = parseInt((this._CHUNK_FILE_SIZE * (4 / 3)).toFixed(), 10);
    if (window.webrtcDetectedBrowser === &#x27;firefox&#x27; &amp;&amp;
      window.webrtcDetectedVersion &lt; 30) {
      chunkSize = this._MOZ_CHUNK_FILE_SIZE;
    }
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetPeerId,
      log: &#x27;Chunk size of data: &#x27;
    }, chunkSize);
    this._uploadDataTransfers[targetPeerId] = this._chunkBlobData(data, dataInfo.size);
    this._uploadDataSessions[targetPeerId] = {
      name: dataInfo.name,
      size: binarySize,
      transferId: dataInfo.transferId,
      timeout: dataInfo.timeout
    };
    this._sendDataChannelMessage(targetPeerId, {
      type: this._DC_PROTOCOL_TYPE.WRQ,
      sender: this._user.sid,
      agent: window.webrtcDetectedBrowser,
      name: dataInfo.name,
      size: binarySize,
      chunkSize: chunkSize,
      timeout: dataInfo.timeout
    });
    this._setDataChannelTimeout(targetPeerId, dataInfo.timeout, true);
  };

  /************************* Datachannel Protocol Methods ****************************/
  /**
   * Handles all datachannel protocol events.
   * @method _dataChannelProtocolHandler
   * @param {String|Object} data The data received from datachannel.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._dataChannelProtocolHandler = function(dataString, peerId, channelName) {
    // PROTOCOL ESTABLISHMENT
    if (typeof dataString === &#x27;string&#x27;) {
      var data = {};
      try {
        data = JSON.parse(dataString);
      } catch (error) {
        this._log(this.LOG_LEVEL.TRACE, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: channelName,
          log: &#x27;Received from peer -&gt;&#x27;
        }, &#x27;DATA&#x27;);
        this._DATAProtocolHandler(peerId, dataString,
          this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING, channelName);
        return;
      }
      this._log(this.LOG_LEVEL.DEBUG, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: channelName,
        log: &#x27;Received from peer -&gt; &#x27;
      }, data.type);
      switch (data.type) {
      case this._DC_PROTOCOL_TYPE.WRQ:
        this._WRQProtocolHandler(peerId, data, channelName);
        break;
      case this._DC_PROTOCOL_TYPE.ACK:
        this._ACKProtocolHandler(peerId, data, channelName);
        break;
      case this._DC_PROTOCOL_TYPE.ERROR:
        this._ERRORProtocolHandler(peerId, data, channelName);
        break;
      case this._DC_PROTOCOL_TYPE.CANCEL:
        this._CANCELProtocolHandler(peerId, data, channelName);
        break;
      case this._DC_PROTOCOL_TYPE.MESSAGE: // Not considered a protocol actually?
        this._MESSAGEProtocolHandler(peerId, data, channelName);
        break;
      default:
        this._log(this.LOG_LEVEL.ERROR, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: channelName,
          log: &#x27;Unsupported message -&gt; &#x27;
        }, data.type);
      }
    }
  };

  /**
   * The user receives a blob request.
   * From here, it&#x27;s up to the user to accept or reject it
   * @method _WRQProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending the request.
   * @param {JSON} data The data object received from datachannel.
   * @param {String} data.agent The peer&#x27;s browser agent.
   * @param {Integer} data.version The peer&#x27;s browser version.
   * @param {String} data.name The data name.
   * @param {Integer} data.size The data size.
   * @param {Integer} data.chunkSize The data chunk size expected to receive.
   * @param {Integer} data.timeout The timeout to wait for packet response.
   * @param {Boolean} data.isPrivate Is the data sent private.
   * @param {String} data.sender The sender&#x27;s peerId.
   * @param {String} data.type The type of datachannel message.
   * @trigger dataTransferState
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._WRQProtocolHandler = function(peerId, data, channelName) {
    var transferId = this._user.sid + this.DATA_TRANSFER_TYPE.DOWNLOAD +
      (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;WRQ&#x27;],
      log: &#x27;Received file request from peer: &#x27;
    }, data);
    var name = data.name;
    var binarySize = data.size;
    var expectedSize = data.chunkSize;
    var timeout = data.timeout;
    this._downloadDataSessions[peerId] = {
      transferId: transferId,
      name: name,
      size: binarySize,
      ackN: 0,
      receivedSize: 0,
      chunkSize: expectedSize,
      timeout: timeout
    };
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.UPLOAD_REQUEST,
      transferId, peerId, {
      name: name,
      size: binarySize,
      senderPeerId: peerId
    });
  };

  /**
   * The user receives an acknowledge of the blob request.
   * @method _ACKProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending the acknowledgement.
   * @param {JSON} data The data object received from datachannel.
   * @param {String} data.ackN The acknowledge request number.
   * - 0: Request accepted. First packet sent.
   * - 0 and above: Transfer is going on.
   * - -1: Request rejected.
   * @param {String} data.sender The sender&#x27;s peerId.
   * @param {String} data.type The type of datachannel message.
   * @trigger dataTransferState
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._ACKProtocolHandler = function(peerId, data, channelName) {
    var self = this;
    var ackN = data.ackN;
    var chunksLength = self._uploadDataTransfers[peerId].length;
    var uploadedDetails = self._uploadDataSessions[peerId];
    var transferId = uploadedDetails.transferId;
    var timeout = uploadedDetails.timeout;

    self._clearDataChannelTimeout(peerId, true);
    self._log(self.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;ACK&#x27;],
      log:&#x27;ACK stage -&gt; &#x27;
    }, ackN + &#x27; / &#x27; + chunksLength);

    if (ackN &gt; -1) {
      // Still uploading
      if (ackN &lt; chunksLength) {
        var fileReader = new FileReader();
        fileReader.onload = function() {
          // Load Blob as dataurl base64 string
          var base64BinaryString = fileReader.result.split(&#x27;,&#x27;)[1];
          self._sendDataChannelMessage(peerId, base64BinaryString);
          self._setDataChannelTimeout(peerId, timeout, true);
          self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOADING,
            transferId, peerId, {
            percentage: (((ackN + 1) / chunksLength) * 100).toFixed()
          });
        };
        fileReader.readAsDataURL(self._uploadDataTransfers[peerId][ackN]);
      } else if (ackN === chunksLength) {
        self._trigger(&#x27;dataTransferState&#x27;,
          self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, transferId, peerId, {
          name: uploadedDetails.name
        });
        delete self._uploadDataTransfers[peerId];
        delete self._uploadDataSessions[peerId];
      }
    } else {
      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.REJECTED,
        transferId, peerId);
      delete self._uploadDataTransfers[peerId];
      delete self._uploadDataSessions[peerId];
    }
  };

  /**
   * The user receives a datachannel broadcast message.
   * @method _MESSAGEProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending a broadcast message.
   * @param {JSON} data The data object received from datachannel.
   * @param {String} data.target The target peerId to receive the data.
   * @param {String|JSON} data.data The data to be received.
   * @param {String} data.sender The sender&#x27;s peerId.
   * @param {String} data.type The type of datachannel message.
   * @trigger incomingMessage
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._MESSAGEProtocolHandler = function(peerId, data, channelName) {
    var targetMid = data.sender;
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;MESSAGE&#x27;],
      log: &#x27;Received P2P message from peer: &#x27;
    }, data);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: data.data,
      isPrivate: data.isPrivate,
      isDataChannel: true,
      targetPeerId: this._user.sid,
      senderPeerId: targetMid
    }, targetMid, this._peerInformations[targetMid], false);
  };

  /**
   * The user receives a timeout error.
   * @method _ERRORProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending the error.
   * @param {Array} data The data object received from datachannel.
   * @param {String} data.name The data name.
   * @param {String} data.content The error message.
   * @param {Boolean} data.isUploadError Is the error occurring at upload state.
   * @param {String} data.sender The sender&#x27;s peerId.
   * @param {String} data.type The type of datachannel message.
   * @trigger dataTransferState
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._ERRORProtocolHandler = function(peerId, data, channelName) {
    var isUploader = data.isUploadError;
    var transferId = (isUploader) ? this._uploadDataSessions[peerId].transferId :
      this._downloadDataSessions[peerId].transferId;
    this._log(this.LOG_LEVEL.ERROR, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;ERROR&#x27;],
      log: &#x27;Received an error from peer: &#x27;
    }, data);
    this._clearDataChannelTimeout(peerId, isUploader);
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
      transferId, peerId, null, {
      name: data.name,
      message: data.content,
      transferType: ((isUploader) ? this.DATA_TRANSFER_TYPE.UPLOAD :
        this.DATA_TRANSFER_TYPE.DOWNLOAD)
    });
  };

  /**
   * The user receives a timeout error.
   * @method _CANCELProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending the error.
   * @param {Array} data The data object received from datachannel.
   * @param {String} data.name The data name.
   * @param {String} data.content The error message.
   * @param {String} data.sender The sender&#x27;s peerId.
   * @param {String} data.type The type of datachannel message.
   * @trigger dataTransferState
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._CANCELProtocolHandler = function(peerId, data, channelName) {
    var isUploader = data.isUploadError;
    var transferId = (isUploader) ? this._uploadDataSessions[peerId].transferId :
      this._downloadDataSessions[peerId].transferId;
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;CANCEL&#x27;],
      log: &#x27;Received file transfer cancel request: &#x27;
    }, data);
    this._clearDataChannelTimeout(peerId, isUploader);
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
      transferId, peerId, null, {
      name: data.name,
      content: data.content,
      senderPeerId: data.sender,
      transferType: ((isUploader) ? this.DATA_TRANSFER_TYPE.UPLOAD :
        this.DATA_TRANSFER_TYPE.DOWNLOAD)
    });
  };

  /**
   * This is when the data is sent from the sender to the receiving user.
   * @method _DATAProtocolHandler
   * @param {String} peerId PeerId of the peer that is sending the data.
   * @param {ArrayBuffer|Blob|String} dataString The data received.
   * @param {String} dataType The data type received from datachannel.
   *   [Rel: Skyway.DATA_TRANSFER_DATA_TYPE]
   * @trigger dataTransferState
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._DATAProtocolHandler = function(peerId, dataString, dataType, channelName) {
    var chunk, error = &#x27;&#x27;;
    var transferStatus = this._downloadDataSessions[peerId];
    var transferId = transferStatus.transferId;
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;DATA&#x27;],
      log: &#x27;Received data chunk from peer. Data type: &#x27;
    }, dataType);

    this._clearDataChannelTimeout(peerId, false);

    if (dataType === this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING) {
      chunk = this._base64ToBlob(dataString);
    } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER) {
      chunk = new Blob(dataString);
    } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.BLOB) {
      chunk = dataString;
    } else {
      error = &#x27;Unhandled data exception: &#x27; + dataType;
      this._log(this.LOG_LEVEL.ERROR, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: [channelName, &#x27;DATA&#x27;],
        log: &#x27;Failed downloading data packets: &#x27;
      }, error);
      this._trigger(&#x27;dataTransferState&#x27;,
        this.DATA_TRANSFER_STATE.ERROR, transferId, peerId, null, {
        message: error,
        transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
      });
      return;
    }
    var receivedSize = (chunk.size * (4 / 3));
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;DATA&#x27;],
      log: &#x27;Received data chunk size: &#x27;
    }, receivedSize);
    this._log(this.LOG_LEVEL.TRACE, {
      target: peerId,
      interface: &#x27;RTCDataChannel&#x27;,
      keys: [channelName, &#x27;DATA&#x27;],
      log: &#x27;Expected data chunk size: &#x27;
    }, transferStatus.chunkSize);

    if (transferStatus.chunkSize &gt;= receivedSize) {
      this._downloadDataTransfers[peerId].push(chunk);
      transferStatus.ackN += 1;
      transferStatus.receivedSize += receivedSize;
      var totalReceivedSize = transferStatus.receivedSize;
      var percentage = ((totalReceivedSize / transferStatus.size) * 100).toFixed();

      this._sendDataChannelMessage(peerId, {
        type: this._DC_PROTOCOL_TYPE.ACK,
        sender: this._user.sid,
        ackN: transferStatus.ackN
      });
      if (transferStatus.chunkSize === receivedSize) {
        this._log(this.LOG_LEVEL.TRACE, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: [channelName, &#x27;DATA&#x27;],
          log: &#x27;Transfer in progress&#x27;
        });
        this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOADING,
          transferId, peerId, {
          percentage: percentage
        });
        this._setDataChannelTimeout(peerId, transferStatus.timeout, false);
        this._downloadDataTransfers[peerId].info = transferStatus;
      } else {
        this._log(this.LOG_LEVEL.TRACE, {
          target: peerId,
          interface: &#x27;RTCDataChannel&#x27;,
          keys: [channelName, &#x27;DATA&#x27;],
          log: &#x27;Download complete&#x27;
        });
        var blob = new Blob(this._downloadDataTransfers[peerId]);
        this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED,
          transferId, peerId, {
          data: blob
        });
        delete this._downloadDataTransfers[peerId];
        delete this._downloadDataSessions[peerId];
      }
    } else {
      error = &#x27;Packet not match - [Received]&#x27; + receivedSize +
        &#x27; / [Expected]&#x27; + transferStatus.chunkSize;
      this._trigger(&#x27;dataTransferState&#x27;,
        this.DATA_TRANSFER_STATE.ERROR, transferId, peerId, null, {
        message: error,
        transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
      });
      this._log(this.LOG_LEVEL.ERROR, {
        target: peerId,
        interface: &#x27;RTCDataChannel&#x27;,
        keys: [channelName, &#x27;DATA&#x27;],
        log: &#x27;Failed downloading data packets: &#x27;
      }, error);
    }
  };

  /************************* Data processing Methods ****************************/
  /**
   * Converts base64 string to raw binary data.
   * - Doesn&#x27;t handle URLEncoded DataURIs
   * - See StackOverflow answer #6850276 for code that does this
   * This is to convert the base64 binary string to a blob
   * @author Code from devnull69 @ stackoverflow.com
   * @method _base64ToBlob
   * @param {String} dataURL Blob base64 dataurl.
   * @private
   * @since 0.1.0
   */
  Skyway.prototype._base64ToBlob = function(dataURL) {
    var byteString = atob(dataURL.replace(/\s\r\n/g, &#x27;&#x27;));
    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var j = 0; j &lt; byteString.length; j++) {
      ia[j] = byteString.charCodeAt(j);
    }
    // write the ArrayBuffer to a blob, and you&#x27;re done
    return new Blob([ab]);
  };

  /**
   * Chunks blob data into chunks.
   * @method _chunkBlobData
   * @param {Blob} blob The blob data to chunk.
   * @param {Integer} blobByteSize The blob data size.
   * @private
   * @since 0.5.2
   */
  Skyway.prototype._chunkBlobData = function(blob, blobByteSize) {
    var chunksArray = [],
      startCount = 0,
      endCount = 0;
    if (blobByteSize &gt; this._CHUNK_FILE_SIZE) {
      // File Size greater than Chunk size
      while ((blobByteSize - 1) &gt; endCount) {
        endCount = startCount + this._CHUNK_FILE_SIZE;
        chunksArray.push(blob.slice(startCount, endCount));
        startCount += this._CHUNK_FILE_SIZE;
      }
      if ((blobByteSize - (startCount + 1)) &gt; 0) {
        chunksArray.push(blob.slice(startCount, blobByteSize - 1));
      }
    } else {
      // File Size below Chunk size
      chunksArray.push(blob);
    }
    return chunksArray;
  };

  /************************* Developer Methods ****************************/
  /**
   * Sets the debugging log level.
   * - The default log level is Skyway.LOG_LEVEL.WARN
   * @method setLogLevel
   * @param {String} logLevel The log level. [Rel: Skyway.LOG_LEVEL]
   * @example
   *   SkywayDemo.setLogLevel(SkywayDemo.LOG_LEVEL.TRACE);
   * @since 0.5.2
   */
  Skyway.prototype.setLogLevel = function(logLevel) {
    for (var level in this.LOG_LEVEL) {
      if (this.LOG_LEVEL[level] === logLevel) {
        this._logLevel = logLevel;
        this._log(this.LOG_LEVEL.TRACE, {
          interface: &#x27;Log&#x27;,
          keys: level,
          log: &#x27;Log level exists. Level is set&#x27;
        });
        return;
      }
    }
    this._log(this.LOG_LEVEL.ERROR, {
      interface: &#x27;Log&#x27;,
      keys: level,
      log: &#x27;Log level does not exist. Level is not set&#x27;
    });
  };

  /**
   * Sets Skyway in debugging mode to display stack trace.
   * - By default, debugging mode is turned off.
   * @method setDebugMode
   * @param {Boolean} isDebugMode If debugging mode is turned on or off.
   * @example
   *   SkywayDemo.setDebugMode(true);
   * @since 0.5.2
   */
  Skyway.prototype.setDebugMode = function(isDebugMode) {
    this._enableDebugMode = isDebugMode;
  };

  /**
   * To register a callback function to an event.
   * @method on
   * @param {String} eventName The Skyway event.
   * @param {Function} callback The callback fired after the event is triggered.
   * @example
   *   SkywayDemo.on(&#x27;peerJoined&#x27;, function (peerId, peerInfo) {
   *      alert(peerId + &#x27; has joined the room&#x27;);
   *   });
   * @since 0.1.0
   */
  Skyway.prototype.on = function(eventName, callback) {
    if (&#x27;function&#x27; === typeof callback) {
      this._EVENTS[eventName] = this._EVENTS[eventName] || [];
      this._EVENTS[eventName].push(callback);
      this._log(this.LOG_LEVEL.TRACE, {
        interface: &#x27;Event&#x27;,
        keys: eventName,
        log: &#x27;Event is subscribed&#x27;
      });
    }
  };

  /**
   * To unregister a callback function from an event.
   * @method off
   * @param {String} eventName The Skyway event.
   * @param {Function} callback The callback fired after the event is triggered.
   * @example
   *   SkywayDemo.off(&#x27;peerJoined&#x27;, callback);
   * @since 0.1.0
   */
  Skyway.prototype.off = function(eventName, callback) {
    if (callback === undefined) {
      this._EVENTS[eventName] = [];
      this._log(this.LOG_LEVEL.ERROR, {
        interface: &#x27;Event&#x27;,
        keys: eventName,
        log: &#x27;Unable to unsubscribe event with invalid callback&#x27;
      });
      return;
    }
    var arr = this._EVENTS[eventName],
      l = arr.length;
    for (var i = 0; i &lt; l; i++) {
      if (arr[i] === callback) {
        arr.splice(i, 1);
        break;
      }
    }
    this._log(this.LOG_LEVEL.TRACE, {
      interface: &#x27;Event&#x27;,
      keys: eventName,
      log: &#x27;Event is unsubscribed&#x27;
    });
  };

  /**
   * Intiailize Skyway to retrieve connection information.
   * - &lt;b&gt;&lt;i&gt;IMPORTANT&lt;/i&gt;&lt;/b&gt;: Please call this method to load all server
   *   information before joining the room or doing anything else.
   * - If you would like to set the start time and duration of the room,
   *   you have to generate the credentials. In example 3, we use the
   *    [CryptoJS](https://code.google.com/p/crypto-js/) library.
   *   - Step 1: Generate the hash. It is created by using the roomname,
   *     duration and the timestamp (in ISO String format).
   *   - Step 2: Generate the Credentials. It is is generated by converting
   *     the hash to a Base64 string and then encoding it to a URI string.
   *   - Step 3: Initialize Skyway
   * @method init
   * @param {String|JSON} options Connection options or API Key ID
   * @param {String} options.apiKey API Key ID to identify with the Temasys
   *   backend server
   * @param {String} options.defaultRoom Optional. The default room to connect
   *   to if there is no room provided in
   *   {{#crossLink &quot;Skyway/joinRoom:method&quot;}}joinRoom(){{/crossLink}}.
   * @param {String} options.roomServer Optional. Path to the Temasys
   *   backend server. If there&#x27;s no room provided, default room would be used.
   * @param {String} options.region Optional. The regional server that user
   *   chooses to use. [Rel: Skyway.REGIONAL_SERVER]
   * @param {Boolean} options.iceTrickle Optional. The option to enable
   *   ICE trickle or not.
   * - Default is true.
   * @param {Boolean} options.dataChannel Optional. The option to enable
   *   datachannel or not.
   * - Default is true.
   * @param {JSON} options.credentials Optional. Credentials options for
   *   setting a static meeting.
   * @param {String} options.credentials.startDateTime The start timing of the
   *   meeting in Date ISO String
   * @param {Integer} options.credentials.duration The duration of the meeting
   * @param {String} options.credentials.credentials The credentials required
   *   to set the timing and duration of a meeting.
   * @example
   *   // Note: Default room is apiKey when no room
   *   // Example 1: To initalize without setting any default room.
   *   SkywayDemo.init(&#x27;apiKey&#x27;);
   *
   *   // Example 2: To initialize with apikey, roomServer and defaultRoom
   *   SkywayDemo.init({
   *     &#x27;apiKey&#x27; : &#x27;apiKey&#x27;,
   *     &#x27;roomServer&#x27; : &#x27;http://xxxx.com&#x27;,
   *     &#x27;defaultRoom&#x27; : &#x27;mainHangout&#x27;
   *   });
   *
   *   // Example 3: To initialize with credentials to set startDateTime and
   *   // duration of the room
   *   var hash = CryptoJS.HmacSHA1(roomname + &#x27;_&#x27; + duration + &#x27;_&#x27; +
   *     (new Date()).toISOString(), token);
   *   var credentials = encodeURIComponent(hash.toString(CryptoJS.enc.Base64));
   *   SkywayDemo.init({
   *     &#x27;apiKey&#x27; : &#x27;apiKey&#x27;,
   *     &#x27;roomServer&#x27; : &#x27;http://xxxx.com&#x27;,
   *     &#x27;defaultRoom&#x27; : &#x27;mainHangout&#x27;
   *     &#x27;credentials&#x27; : {
   *        &#x27;startDateTime&#x27; : (new Date()).toISOString(),
   *        &#x27;duration&#x27; : 500,
   *        &#x27;credentials&#x27; : credentials
   *     }
   *   });
   * @trigger readyStateChange
   * @for Skyway
   * @required
   * @since 0.5.2
   */
  Skyway.prototype.init = function(options) {
    if (!options) {
      this._log(this.LOG_LEVEL.ERROR, &#x27;No API key provided&#x27;);
      return;
    }
    var apiKey, room, defaultRoom, region;
    var startDateTime, duration, credentials;
    var roomServer = this._roomServer;
    var iceTrickle = true;
    var dataChannel = true;

    this._log(this.LOG_LEVEL.TRACE, &#x27;Provided init options: &#x27;, options);

    if (typeof options === &#x27;string&#x27;) {
      apiKey = options;
      defaultRoom = apiKey;
      room = apiKey;
    } else {
      apiKey = options.apiKey;
      roomServer = options.roomServer || roomServer;
      roomServer = (roomServer.lastIndexOf(&#x27;/&#x27;) ===
        (roomServer.length - 1)) ? roomServer.substring(0,
        roomServer.length - 1) : roomServer;
      region = options.region || region;
      defaultRoom = options.defaultRoom || apiKey;
      room = defaultRoom;
      iceTrickle = (typeof options.iceTrickle === &#x27;boolean&#x27;) ?
        options.iceTrickle : iceTrickle;
      dataChannel = (typeof options.dataChannel === &#x27;boolean&#x27;) ?
        options.dataChannel : dataChannel;
      // Custom default meeting timing and duration
      // Fallback to default if no duration or startDateTime provided
      if (options.credentials) {
        startDateTime = options.credentials.startDateTime ||
          (new Date()).toISOString();
        duration = options.credentials.duration || 200;
        credentials = options.credentials.credentials;
      }
    }
    this._readyState = 0;
    this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.INIT);
    this._apiKey = apiKey;
    this._roomServer = roomServer;
    this._defaultRoom = defaultRoom;
    this._selectedRoom = room;
    this._serverRegion = region;
    this._enableIceTrickle = iceTrickle;
    this._enableDataChannel = dataChannel;
    this._path = roomServer + &#x27;/api/&#x27; + apiKey + &#x27;/&#x27; + room;
    if (credentials) {
      this._roomStart = startDateTime;
      this._roomDuration = duration;
      this._roomCredentials = credentials;
      this._path += (credentials) ? (&#x27;/&#x27; + startDateTime + &#x27;/&#x27; +
        duration + &#x27;?&amp;cred=&#x27; + credentials) : &#x27;&#x27;;
    }
    if (region) {
      this._path += ((this._path.indexOf(&#x27;?&amp;&#x27;) &gt; -1) ?
        &#x27;&amp;&#x27; : &#x27;?&amp;&#x27;) + &#x27;rg=&#x27; + region;
    }
    this._log(this.LOG_LEVEL.TRACE, &#x27;Init configuration: &#x27;, {
      serverUrl: this._path,
      readyState: this._readyState,
      apiKey: this._apiKey,
      roomServer: this._roomServer,
      defaultRoom: this._defaultRoom,
      selectedRoom: this._selectedRoom,
      serverRegion: this._serverRegion,
      enableDataChannel: this._enableDataChannel,
      enableIceTrickle: this._enableIceTrickle
    });
    this._loadInfo();
  };

  /**
   * Gets the default webcam and microphone.
   * - Please do not be confused with the [MediaStreamConstraints](http://dev.w3.
   *   org/2011/webrtc/editor/archives/20140817/getusermedia.html#dictionary
   *   -mediastreamconstraints-members) specified in the original w3c specs.
   * - This is an implemented function for Skyway.
   * @method getUserMedia
   * @param {JSON} options Optional. MediaStream constraints.
   * @param {JSON|Boolean} options.audio Option to allow audio stream.
   * @param {Boolean} options.audio.stereo Option to enable stereo
   *    during call.
   * @param {JSON|Boolean} options.video Option to allow video stream.
   * @param {JSON} options.video.resolution The resolution of video stream.
   * - Check out &lt;a href=&quot;#attr_VIDEO_RESOLUTION&quot;&gt;VIDEO_RESOLUTION&lt;/a&gt;.
   * @param {Integer} options.video.resolution.width
   *   The video stream resolution width.
   * @param {Integer} options.video.resolution.height
   *   The video stream resolution height.
   * @param {Integer} options.video.frameRate
   *   The video stream mininum frameRate.
   * @example
   *   // Default is to get both audio and video
   *   // Example 1: Get both audio and video by default.
   *   SkywayDemo.getUserMedia();
   *
   *   // Example 2: Get the audio stream only
   *   SkywayDemo.getUserMedia({
   *     &#x27;video&#x27; : false,
   *     &#x27;audio&#x27; : true
   *   });
   *
   *   // Example 3: Set the stream settings for the audio and video
   *   SkywayDemo.getUserMedia({
   *     &#x27;video&#x27; : {
   *        &#x27;resolution&#x27;: SkywayDemo.VIDEO_RESOLUTION.HD,
   *        &#x27;frameRate&#x27;: 50
   *      },
   *     &#x27;audio&#x27; : {
   *       &#x27;stereo&#x27;: true
   *     }
   *   });
   * @trigger mediaAccessSuccess, mediaAccessError
   * @since 0.4.1
   */
  Skyway.prototype.getUserMedia = function(options) {
    var self = this;
    var getStream = false;
    options = options || {
      audio: true,
      video: true
    };
    // prevent undefined error
    self._user = self._user || {};
    self._user.info = self._user.info || {};
    self._user.info.settings = self._user.info.settings || {};
    self._user.streams = self._user.streams || [];
    // called during joinRoom
    if (self._user.info.settings) {
      // So it would invoke to getMediaStream defaults
      if (!options.video &amp;&amp; !options.audio) {
        self._log(self.LOG_LEVEL.INFO, &#x27;No audio or video stream is requested&#x27;);
      } else if (self._user.info.settings.audio !== options.audio ||
        self._user.info.settings.video !== options.video) {
        if (Object.keys(self._user.streams).length &gt; 0) {
          // NOTE: User&#x27;s stream may hang.. so find a better way?
          // NOTE: Also make a use case for multiple streams?
          getStream = self._setLocalMediaStreams(options);
          if (getStream) {
            // NOTE: When multiple streams, streams should not be cleared.
            self._user.streams = [];
          }
        } else {
          getStream = true;
        }
      }
    } else { // called before joinRoom
      getStream = true;
    }
    self._parseStreamSettings(options);
    if (getStream) {
      try {
        window.getUserMedia({
          audio: self._streamSettings.audio,
          video: self._streamSettings.video
        }, function(stream) {
          self._onUserMediaSuccess(stream);
        }, function(error) {
          self._onUserMediaError(error);
        });
      } catch (error) {
        self._onUserMediaError(error);
      }
    } else if (Object.keys(self._user.streams).length &gt; 0) {
      self._log(self.LOG_LEVEL.TRACE, {
        interface: &#x27;MediaStream&#x27;,
        log: &#x27;User has already this mediastream. Reactiving media&#x27;
      });
    } else {
      self._log(self.LOG_LEVEL.WARN, {
        interface: &#x27;MediaStream&#x27;,
        log: &#x27;Not retrieving stream&#x27;
      });
    }
  };

  /**
   * User to join the room.
   * - You may call {{#crossLink &quot;Skyway/getUserMedia:method&quot;}}
   *   getUserMedia(){{/crossLink}} first if you want to get
   *   MediaStream and joining Room seperately.
   * - If &lt;b&gt;joinRoom()&lt;/b&gt; parameters is empty, it simply uses
   *   any previous media or user data settings.
   * - If no room is specified, user would be joining the default room.
   * @method joinRoom
   * @param {String} room Optional. Room to join user in.
   * @param {JSON} options Optional. Media Constraints.
   * @param {JSON|String} options.userData Optional. User custom data.
   * @param {Boolean|JSON} options.audio This call requires audio stream.
   * @param {Boolean} options.audio.stereo Option to enable stereo
   *    during call.
   * @param {Boolean|JSON} options.video This call requires video stream.
   * @param {JSON} options.video.resolution The resolution of video stream.
   *   [Rel: Skyway.VIDEO_RESOLUTION]
   * @param {Integer} options.video.resolution.width
   *   The video stream resolution width.
   * @param {Integer} options.video.resolution.height
   *   The video stream resolution height.
   * @param {Integer} options.video.frameRate
   *   The video stream mininum frameRate.
   * @param {JSON} options.bandwidth Stream bandwidth settings.
   * @param {Integer} options.bandwidth.audio Audio stream bandwidth in kbps.
   * - Recommended: 50 kbps.
   * @param {Integer} options.bandwidth.video Video stream bandwidth in kbps.
   * - Recommended: 256 kbps.
   * @param {Integer} options.bandwidth.data Data stream bandwidth in kbps.
   * - Recommended: 1638400 kbps.
   * @example
   *   // To just join the default room without any video or audio
   *   // Note that calling joinRoom without any parameters
   *   // Still sends any available existing MediaStreams allowed.
   *   // See Examples 2, 3, 4 and 5 etc to prevent video or audio stream
   *   SkywayDemo.joinRoom();
   *
   *   // To just join the default room with bandwidth settings
   *   SkywayDemo.joinRoom({
   *     &#x27;bandwidth&#x27;: {
   *       &#x27;data&#x27;: 14440
   *     }
   *   });
   *
   *   // Example 1: To call getUserMedia and joinRoom seperately
   *   SkywayDemo.getUserMedia();
   *   SkywayDemo.on(&#x27;mediaAccessSuccess&#x27;, function (stream)) {
   *     attachMediaStream($(&#x27;.localVideo&#x27;)[0], stream);
   *     SkywayDemo.joinRoom();
   *   });
   *
   *   // Example 2: Join a room without any video or audio
   *   SkywayDemo.joinRoom(&#x27;room&#x27;);
   *
   *   // Example 3: Join a room with audio only
   *   SkywayDemo.joinRoom(&#x27;room&#x27;, {
   *     &#x27;audio&#x27; : true,
   *     &#x27;video&#x27; : false
   *   });
   *
   *   // Example 4: Join a room with prefixed video width and height settings
   *   SkywayDemo.joinRoom(&#x27;room&#x27;, {
   *     &#x27;audio&#x27; : true,
   *     &#x27;video&#x27; : {
   *       &#x27;resolution&#x27; : {
   *         &#x27;width&#x27; : 640,
   *         &#x27;height&#x27; : 320
   *       }
   *     }
   *   });
   *
   *   // Example 5: Join a room with userData and settings with audio, video
   *   // and bandwidth
   *   SkwayDemo.joinRoom({
   *     &#x27;userData&#x27;: {
   *       &#x27;item1&#x27;: &#x27;My custom data&#x27;,
   *       &#x27;item2&#x27;: &#x27;Put whatever, string or JSON or array&#x27;
   *     },
   *     &#x27;audio&#x27; : {
   *        &#x27;stereo&#x27; : true
   *      },
   *     &#x27;video&#x27; : {
   *        &#x27;res&#x27; : SkywayDemo.VIDEO_RESOLUTION.VGA,
   *        &#x27;frameRate&#x27; : 50
   *     },
   *     &#x27;bandwidth&#x27; : {
   *        &#x27;audio&#x27; : 48,
   *        &#x27;video&#x27; : 256,
   *        &#x27;data&#x27; : 14480
   *      }
   *   });
   * @trigger peerJoined
   * @since 0.5.0
   */
  Skyway.prototype.joinRoom = function(room, mediaOptions) {
    var self = this;
    if ((self._inRoom &amp;&amp; typeof room !== &#x27;string&#x27;) || (typeof room === &#x27;string&#x27; &amp;&amp;
      room === this._selectedRoom)) {
      self._log(self.LOG_LEVEL.ERROR, {
        interface: &#x27;Socket&#x27;,
        keys: ((typeof room === &#x27;string&#x27;) ? room : self._selectedRoom),
        log: &#x27;Unable to join room as user is currently in the room already&#x27;
      });
      return;
    }
    self._log(self.LOG_LEVEL.TRACE, {
      interface: &#x27;Socket&#x27;,
      keys: self._selectedRoom,
      log: &#x27;Joining room. Media options: &#x27;
    }, mediaOptions || ((typeof room === &#x27;object&#x27;) ? room : {}));
    var sendJoinRoomMessage = function() {
      self._sendChannelMessage({
        type: self._SIG_MESSAGE_TYPE.JOIN_ROOM,
        uid: self._user.uid,
        cid: self._key,
        rid: self._room.id,
        userCred: self._user.token,
        timeStamp: self._user.timeStamp,
        apiOwner: self._apiKeyOwner,
        roomCred: self._room.token,
        start: self._room.startDateTime,
        len: self._room.duration
      });
    };
    var doJoinRoom = function() {
      var checkChannelOpen = setInterval(function () {
        if (!self._channelOpen) {
          if (self._readyState === self.READY_STATE_CHANGE.COMPLETED) {
            self._openChannel();
          }
        } else {
          clearInterval(checkChannelOpen);
          self._waitForLocalMediaStream(function() {
            sendJoinRoomMessage();
          }, mediaOptions);
        }
      }, 500);
    };
    if (typeof room === &#x27;string&#x27;) {
      self._initSelectedRoom(room, doJoinRoom);
    } else {
      mediaOptions = room;
      doJoinRoom();
    }
  };

  /**
   * User to leave the room.
   * @method leaveRoom
   * @example
   *   SkywayDemo.leaveRoom();
   * @trigger peerLeft, channelClose
   * @since 0.1.0
   */
  Skyway.prototype.leaveRoom = function() {
    if (!this._inRoom) {
      this._log(this.LOG_LEVEL.ERROR, &#x27;Unable to leave room as user is not in any room&#x27;);
      return;
    }
    for (var pc_index in this._peerConnections) {
      if (this._peerConnections.hasOwnProperty(pc_index)) {
        this._removePeer(pc_index);
      }
    }
    this._inRoom = false;
    this._closeChannel();
    this._log(this.LOG_LEVEL.TRACE, {
      interface: &#x27;Socket&#x27;,
      keys: this._selectedRoom,
      log: &#x27;User left the room&#x27;
    });
    this._trigger(&#x27;peerLeft&#x27;, this._user.sid, this._user.info, true);
  };

  /**
   * Broadcast a message to all peers.
   * - &lt;b&gt;&lt;i&gt;WARNING&lt;/i&gt;&lt;/b&gt;: Map arrays data would be lost when stringified
   *   in JSON, so refrain from using map arrays.
   * @method sendMessage
   * @param {String|JSON} message The message data to send.
   * @param {String} targetPeerId PeerId of the peer to send a private
   *   message data to.
   * @example
   *   // Example 1: Send to all peers
   *   SkywayDemo.sendMessage(&#x27;Hi there!&#x27;);
   *
   *   // Example 2: Send to a targeted peer
   *   SkywayDemo.sendMessage(&#x27;Hi there peer!&#x27;, targetPeerId);
   * @trigger incomingMessage
   * @since 0.4.0
   */
  Skyway.prototype.sendMessage = function(message, targetPeerId) {
    var params = {
      cid: this._key,
      data: message,
      mid: this._user.sid,
      rid: this._room.id,
      type: this._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE
    };
    if (targetPeerId) {
      params.target = targetPeerId;
      params.type = this._SIG_MESSAGE_TYPE.PRIVATE_MESSAGE;
    }
    this._log(this.LOG_LEVEL.TRACE, {
      target: targetPeerId,
      log: &#x27;Sending message to peer&#x27; + ((targetPeerId) ? &#x27;s&#x27; : &#x27;&#x27;)
    });
    this._sendChannelMessage(params);
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message,
      isPrivate: (targetPeerId) ? true: false,
      targetPeerId: targetPeerId || null,
      isDataChannel: false,
      senderPeerId: this._user.sid
    }, this._user.sid, this._user.info, true);
  };

  /**
   * Start a data transfer with peer(s).
   * - Note that peers have the option to download or reject receiving the blob data.
   * - This method is ideal for sending files.
   * - To send a private file to a peer, input the peerId after the
   *   data information.
   * @method sendBlobData
   * @param {Object} data The data to be sent over. Data has to be a blob.
   * @param {JSON} dataInfo The data information.
   * @param {String} dataInfo.transferId transferId of the data.
   * @param {String} dataInfo.name Data name.
   * @param {Integer} dataInfo.timeout The timeout to wait for packets.
   *   [Default is 60].
   * @param {Integer} dataInfo.size The data size
   * @param {String} targetPeerId PeerId targeted to receive data.
   *   Leave blank to send to all peers.
   * @example
   *   // Send file to all peers connected
   *   SkywayDemo.sendBlobData(file, 67);
   *
   *   // Send file to individual peer
   *   SkywayDemo.sendBlobData(blob, 87, targetPeerId);
   * @trigger dataTransferState
   * @since 0.5.2
   */
  Skyway.prototype.sendBlobData = function(data, dataInfo, targetPeerId) {
    if (!data &amp;&amp; !dataInfo) {
      return false;
    }
    // check if datachannel is enabled first or not
    if (!this._enableDataChannel) {
      this._log(this.LOG_LEVEL.WARN, &#x27;Unable to send any blob data. &#x27; +
        &#x27;Datachannel is disabled&#x27;);
      return;
    }
    var noOfPeersSent = 0;
    dataInfo.timeout = dataInfo.timeout || 60;
    dataInfo.transferId = this._user.sid + this.DATA_TRANSFER_TYPE.UPLOAD +
      (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);

    if (targetPeerId) {
      if (this._dataChannels.hasOwnProperty(targetPeerId)) {
        this._log(this.LOG_LEVEL.TRACE, {
          target: targetPeerId,
          log: &#x27;Sending blob data -&gt; &#x27;
        }, dataInfo);
        this._sendBlobDataToPeer(data, dataInfo, targetPeerId);
        noOfPeersSent = 1;
      } else {
        this._log(this.LOG_LEVEL.ERROR, {
          target: targetPeerId,
          log: &#x27;Datachannel does not exist&#x27;
        });
      }
    } else {
      targetpeerId = this._user.sid;
      for (var peerId in this._dataChannels) {
        if (this._dataChannels.hasOwnProperty(peerId)) {
          // Binary String filesize [Formula n = 4/3]
          this._sendBlobDataToPeer(data, dataInfo, peerId);
          noOfPeersSent++;
        } else {
          this._log(this.LOG_LEVEL.ERROR, {
            target: peerId,
            log: &#x27;Datachannel does not exist&#x27;
          });
        }
      }
    }
    if (noOfPeersSent &gt; 0) {
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.UPLOAD_STARTED,
        dataInfo.transferId, targetPeerId, {
        transferId: dataInfo.transferId,
        senderPeerId: this._user.sid,
        name: dataInfo.name,
        size: dataInfo.size,
        timeout: dataInfo.timeout || 60,
        data: data
      });
    } else {
      var error = &#x27;No available datachannels to send data.&#x27;;
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
        transferId, targetPeerId, null, {
        message: error,
        transferType: this.DATA_TRANSFER_TYPE.UPLOAD
      });
      this._log(this.LOG_LEVEL.ERROR, &#x27;Failed sending data: &#x27;, error);
      this._uploadDataTransfers = [];
      this._uploadDataSessions = [];
    }
  };

  /**
   * User&#x27;s response to accept or reject data transfer request.
   * @method respondBlobRequest
   * @param {String} peerId PeerId of the peer that is expected to receive
   *   the request response.
   * @param {Boolean} accept The response of the user to accept the data
   *   transfer or not.
   * @trigger dataTransferState
   * @since 0.5.0
   */
  Skyway.prototype.respondBlobRequest = function (peerId, accept) {
    if (accept) {
      this._log(this.LOG_LEVEL.INFO, {
        target: peerId,
        log: &#x27;User accepted peer\&#x27;s request&#x27;
      });
      this._downloadDataTransfers[peerId] = [];
      var data = this._downloadDataSessions[peerId];
      this._sendDataChannelMessage(peerId, {
        type: this._DC_PROTOCOL_TYPE.ACK,
        sender: this._user.sid,
        ackN: 0,
        agent: window.webrtcDetectedBrowser
      });
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
        data.transferId, peerId, {
        name: data.name,
        size: data.size,
        senderPeerId: peerId
      });
    } else {
      this._log(this.LOG_LEVEL.INFO, {
        target: peerId,
        log: &#x27;User rejected peer\&#x27;s request&#x27;
      });
      this._sendDataChannelMessage(peerId, {
        type: this._DC_PROTOCOL_TYPE.ACK,
        sender: this._user.sid,
        ackN: -1
      });
      delete this._downloadDataSessions[peerId];
    }
  };

  /**
   * Reject file transfer for cancel.
   * @method cancelBlobTransfer
   * @param {String} peerId PeerId of the peer that is expected to receive
   *   the request response.
   * @param {String} transferType Transfer type [Rel: DATA_TRANSFER_TYPE]
   * @trigger dataTransferState
   * @since 0.5.0
   */
  Skyway.prototype.cancelBlobTransfer = function (peerId, transferType) {
    if (accept) {
      this._downloadDataTransfers[peerId] = [];
      var data = this._downloadDataSessions[peerId];
      this._sendDataChannelMessage(peerId, {
        type: this._DC_PROTOCOL_TYPE.ACK,
        sender: this._user.sid,
        ackN: 0,
        agent: window.webrtcDetectedBrowser
      });
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
        data.transferId, peerId, {
        name: data.name,
        size: data.size,
        senderPeerId: peerId
      });
    } else {
      this._sendDataChannelMessage(peerId, {
        type: this._DC_PROTOCOL_TYPE.ACK,
        sender: this._user.sid,
        ackN: -1
      });
      delete this._downloadDataSessions[peerId];
    }
  };

  /**
   * Broadcasts to all P2P datachannel messages and sends to a
   * peer only when targetPeerId is provided.
   * - This is ideal for sending strings or json objects lesser than 16KB
   *   [as noted in here](http://www.webrtc.org/chrome).
   * - For huge data, please check out function
   *   {{#crossLink &quot;Skyway/sendBlobData:method&quot;}}sendBlobData(){{/crossLink}}.
   * - &lt;b&gt;&lt;i&gt;WARNING&lt;/i&gt;&lt;/b&gt;: Map arrays data would be lost when stringified
   *   in JSON, so refrain from using map arrays.
   * @method sendP2PMessage
   * @param {String|JSON} message The message data to send.
   * @param {String} targetPeerId Optional. Provide if you want to send to
   *   only one peer
   * @example
   *   // Example 1: Send to all peers
   *   SkywayDemo.sendP2PMessage(&#x27;Hi there! This is from a DataChannel!&#x27;);
   *
   *   // Example 2: Send to specific peer
   *   SkywayDemo.sendP2PMessage(&#x27;Hi there peer! This is from a DataChannel!&#x27;, targetPeerId);
   * @trigger incomingMessage
   * @since 0.5.2
   */
  Skyway.prototype.sendP2PMessage = function(message, targetPeerId) {
    // check if datachannel is enabled first or not
    if (!this._enableDataChannel) {
      this._log(this.LOG_LEVEL.WARN, &#x27;Unable to send any P2P message. &#x27; +
        &#x27;Datachannel is disabled&#x27;);
      return;
    }
    // Handle typeof object sent over
    for (var peerId in this._dataChannels) {
      if (this._dataChannels.hasOwnProperty(peerId)) {
        if ((targetPeerId &amp;&amp; targetPeerId === peerId) || !targetPeerId) {
          this._log(this.LOG_LEVEL.TRACE, {
            target: peerId,
            log: &#x27;Sending P2P message to peer&#x27;
          });
          this._sendDataChannelMessage(peerId, {
            type: this._DC_PROTOCOL_TYPE.MESSAGE,
            isPrivate: !!targetPeerId,
            sender: this._user.sid,
            target: targetPeerId,
            data: message
          });
        }
      }
    }
    this._trigger(&#x27;incomingMessage&#x27;, {
      content: message,
      isPrivate: (targetPeerId) ? true : false,
      targetPeerId: targetPeerId || null, // is not null if there&#x27;s user
      isDataChannel: true,
      senderPeerId: this._user.sid
    }, this._user.sid, this._user.info, true);
  };

  /**
   * Updates the user custom data.
   * - Please note that the custom data would be overrided so please call
   *   {{#crossLink &quot;Skyway/getUserData:method&quot;}}getUserData(){{/crossLink}}
   *   and then modify the information you want individually.
   * - {{#crossLink &quot;Skyway/peerUpdated:event&quot;}}peerUpdated{{/crossLink}}
   *   only fires after &lt;b&gt;setUserData()&lt;/b&gt; is fired.
   *   after the user joins the room.
   * @method setUserData
   * @param {JSON|String} userData User custom data.
   * @example
   *   // Example 1: Intial way of setting data before user joins the room
   *   SkywayDemo.setUserData({
   *     displayName: &#x27;Bobby Rays&#x27;,
   *     fbUserId: &#x27;blah&#x27;
   *   });
   *
   *  // Example 2: Way of setting data after user joins the room
   *   var userData = SkywayDemo.getUserData();
   *   userData.displayName = &#x27;New Name&#x27;;
   *   userData.fbUserId = &#x27;another Id&#x27;;
   *   SkywayDemo.setUserData(userData);
   * @trigger peerUpdated
   * @since 0.4.1
   */
  Skyway.prototype.setUserData = function(userData) {
    var self = this;
    // NOTE ALEX: be smarter and copy fields and only if different
    if (self._readyState === self.READY_STATE_CHANGE.COMPLETED) {
      self._user.info = self._user.info || {};
      self._user.info.userData = userData ||
        self._user.info.userData || {};

      if (self._inRoom) {
        self._log(self.LOG_LEVEL.TRACE, &#x27;Updated userData -&gt; &#x27;, userData);
        self._sendChannelMessage({
          type: self._SIG_MESSAGE_TYPE.UPDATE_USER,
          mid: self._user.sid,
          rid: self._room.id,
          userData: self._user.info.userData
        });
        self._trigger(&#x27;peerUpdated&#x27;, self._user.sid, self._user.info, true);
      } else {
        self._log(self.LOG_LEVEL.WARN, &#x27;User is not in the room. Broadcast of&#x27; +
          &#x27; updated information will be dropped&#x27;);
      }
    } else {
      var checkInRoom = setInterval(function () {
        if (self._readyState === self.READY_STATE_CHANGE.COMPLETED) {
          clearInterval(checkInRoom);
          self.setUserData(userData);
        }
      }, 50);
    }
  };

  /**
   * Gets the user custom data.
   * @method getUserData
   * @return {JSON|String} User custom data.
   * @example
   *   var userInfo = SkywayDemo.getUserData();
   * @since 0.4.0
   */
  Skyway.prototype.getUserData = function() {
    return (this._user) ?
      ((this._user.info) ? (this._user.info.userData || &#x27;&#x27;)
      : &#x27;&#x27;) : &#x27;&#x27;;
  };

  /**
   * Gets the peer information.
   * - If input peerId is user&#x27;s id or empty, &lt;b&gt;getPeerInfo()&lt;/b&gt;
   *   would return user&#x27;s peer information.
   * @method getPeerInfo
   * @param {String} peerId PeerId of the peer information to retrieve.
   * @return {JSON} Peer information.
   * @example
   *   // Example 1: To get other peer&#x27;s information
   *   var peerInfo = SkywayDemo.getPeerInfo(peerId);
   *
   *   // Example 2: To get own information
   *   var userInfo = SkywayDemo.getPeerInfo();
   * @since 0.4.0
   */
  Skyway.prototype.getPeerInfo = function(peerId) {
    return (peerId &amp;&amp; peerId !== this._user.sid) ?
      this._peerInformations[peerId] :
      ((this._user) ? this._user.info : null);
  };

  /**
   * Lock the room to prevent peers from joining the room.
   * @method lockRoom
   * @example
   *   SkywayDemo.lockRoom();
   * @trigger lockRoom
   * @since 0.5.0
   */
  Skyway.prototype.lockRoom = function() {
    this._log(this.LOG_LEVEL.TRACE, &#x27;Update to isRoomLocked status -&gt; &#x27;, true);
    this._sendChannelMessage({
      type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,
      mid: this._user.sid,
      rid: this._room.id,
      lock: true
    });
    this._trigger(&#x27;roomLock&#x27;, true, this._user.sid,
      this._user.info, true);
  };

  /**
   * Unlock the room to allow peers to join the room.
   * @method unlockRoom
   * @example
   *   SkywayDemo.unlockRoom();
   * @trigger lockRoom
   * @since 0.5.0
   */
  Skyway.prototype.unlockRoom = function() {
    this._log(this.LOG_LEVEL.TRACE, &#x27;Update to isRoomLocked status -&gt; &#x27;, false);
    this._sendChannelMessage({
      type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,
      mid: this._user.sid,
      rid: this._room.id,
      lock: false
    });
    this._trigger(&#x27;roomLock&#x27;, false, this._user.sid,
      this._user.info, true);
  };

  /**
   * Enable microphone.
   * - If microphone is not enabled from the beginning, user would have to reinitate the
   *   {{#crossLink &quot;Skyway/joinRoom:method&quot;}}joinRoom(){{/crossLink}}
   *   process and ask for microphone again.
   * @method enableAudio
   * @trigger peerUpdated
   * @example
   *   SkywayDemo.enableAudio();
   * @since 0.4.0
   */
  Skyway.prototype.enableAudio = function() {
    this._handleLocalMediaStreams(&#x27;audio&#x27;, true);
  };

  /**
   * Disable microphone.
   * - If microphone is not enabled from the beginning, there is no effect.
   * @method disableAudio
   * @example
   *   SkywayDemo.disableAudio();
   * @trigger peerUpdated
   * @since 0.4.0
   */
  Skyway.prototype.disableAudio = function() {
    this._handleLocalMediaStreams(&#x27;audio&#x27;, false);
  };

  /**
   * Enable webcam video.
   * - If webcam is not enabled from the beginning, user would have to reinitate the
   *   {{#crossLink &quot;Skyway/joinRoom:method&quot;}}joinRoom(){{/crossLink}}
   *   process and ask for webcam again.
   * @method enableVideo
   * @example
   *   SkywayDemo.enableVideo();
   * @trigger peerUpdated
   * @since 0.4.0
   */
  Skyway.prototype.enableVideo = function() {
    this._handleLocalMediaStreams(&#x27;video&#x27;, true);
  };

  /**
   * Disable webcam video.
   * - If webcam is not enabled from the beginning, there is no effect.
   * - Note that in a Chrome-to-chrome session, each party&#x27;s peer audio
   *   may appear muted in when the audio is muted.
   * - You may follow up the bug on [here](https://github.com/Temasys/SkywayJS/issues/14).
   * @method disableVideo
   * @example
   *   SkywayDemo.disableVideo();
   * @trigger peerUpdated
   * @since 0.4.0
   */
  Skyway.prototype.disableVideo = function() {
    this._handleLocalMediaStreams(&#x27;video&#x27;, false);
  };
}).call(this);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
